import _initializerDefineProperty from "@babel/runtime/helpers/initializerDefineProperty";
import _applyDecoratedDescriptor from "@babel/runtime/helpers/applyDecoratedDescriptor";
import _initializerWarningHelper from "@babel/runtime/helpers/initializerWarningHelper";
var _class,
  _descriptor,
  _descriptor2,
  _descriptor3,
  _descriptor4,
  _descriptor5,
  _descriptor6,
  _descriptor7,
  _descriptor8,
  _descriptor9,
  _descriptor10,
  _descriptor11,
  _descriptor12,
  _descriptor13,
  _descriptor14,
  _descriptor15,
  _descriptor16,
  _descriptor17;
import { action, observable } from "mobx";
import { udSentry } from "@udemy/sentry";
import { udApi } from "@udemy/ud-api";
import {
  NOTIFICATION_EVENTS,
  NO_REFRESH_EVENTS,
  API_ROUTES,
  LIMITS,
  ALLOWED_ASSET_TYPES,
  CONTENT_LOCKED_EVENT,
  LECTURES_VIEWED_EVENT,
  INITIAL_FREE_LECTURES_AVAILABLE,
  MAX_FREE_LECTURES_AVAILABLE,
} from "../constants";
export let LimitedConsumptionTrialStore =
  ((_class = class LimitedConsumptionTrialStore {
    constructor(getTooltipProps, getOrgNumericSiteStat) {
      this.getTooltipProps = getTooltipProps;
      this.getOrgNumericSiteStat = getOrgNumericSiteStat;
      this.limits = void 0;
      _initializerDefineProperty(this, "availableLectures", _descriptor, this);
      _initializerDefineProperty(this, "usedLectures", _descriptor2, this);
      _initializerDefineProperty(this, "notificationEvent", _descriptor3, this);
      _initializerDefineProperty(
        this,
        "notificationEventDetail",
        _descriptor4,
        this
      );
      _initializerDefineProperty(this, "ownerName", _descriptor5, this);
      _initializerDefineProperty(
        this,
        "activeRemainingDays",
        _descriptor6,
        this
      );
      _initializerDefineProperty(this, "currentTooltip", _descriptor7, this);
      _initializerDefineProperty(this, "isLoading", _descriptor8, this);
      _initializerDefineProperty(this, "isOwner", _descriptor9, this);
      _initializerDefineProperty(
        this,
        "isOrgLimitReached",
        _descriptor10,
        this
      );
      _initializerDefineProperty(
        this,
        "isNudgeOwnerModalVisible",
        _descriptor11,
        this
      );
      _initializerDefineProperty(
        this,
        "isLockedLectureModalVisible",
        _descriptor12,
        this
      );
      /**
       * Handle Event to show Notification tooltip and refresh the state from API if needed
       * @param type - event name
       * @param detail - event detail
       */
      _initializerDefineProperty(this, "handleEvent", _descriptor13, this);
      _initializerDefineProperty(
        this,
        "showNudgeOwnerModal",
        _descriptor14,
        this
      );
      _initializerDefineProperty(
        this,
        "hideNudgeOwnerModal",
        _descriptor15,
        this
      );
      _initializerDefineProperty(
        this,
        "showLockedLecturesModal",
        _descriptor16,
        this
      );
      _initializerDefineProperty(
        this,
        "hideLockedLecturesModal",
        _descriptor17,
        this
      );
      this.toggleOverlay();
      this.limits = LIMITS;
      this.limits.minLectures = INITIAL_FREE_LECTURES_AVAILABLE;
      this.limits.maxLectures = MAX_FREE_LECTURES_AVAILABLE;
    }

    /**
     * Main method for refreshing the state of trial bar using the API endpoint
     * @param tooltip - trigger an event tooltip or not
     */
    getStatus() {
      let tooltip =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : false;
      return udApi
        .get(API_ROUTES.status)
        .then(
          action((response) => {
            this.activeRemainingDays = response.data.active_remaining_days;
            this.availableLectures = response.data.available_count;
            this.usedLectures = response.data.used_count;
            this.ownerName = response.data.owner_name;
            this.isOwner = response.data.is_owner;
            this.isLoading = false;
            this.isOrgLimitReached = !!response.data.trial_limit_reached;
            if (tooltip) {
              this.handleNotificationEvent();
            }
          })
        )
        .catch((e) => {
          udSentry.captureException(e);
        });
    }

    /**
     * Show / hide page overlay for `Get started` state
     * @param show - desired state
     */
    toggleOverlay() {
      let show =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : false;
      if (!show) {
        // hide tooltip with overlay
        this.currentTooltip = undefined;
      }
    }
    /**
     * Handle notification events and generate tooltip content data based on the relevant event
     */
    handleNotificationEvent() {
      let tooltip = undefined;
      switch (this.notificationEvent) {
        case CONTENT_LOCKED_EVENT:
          if (
            !this.isOrgLimitReached &&
            this.notificationEventDetail &&
            this.notificationEventDetail.itemType === "lecture" &&
            ALLOWED_ASSET_TYPES.includes(this.notificationEventDetail.assetType)
          ) {
            this.showLockedLecturesModal();
          } else {
            tooltip = this._lockedTooltip();
          }
          break;
        case LECTURES_VIEWED_EVENT:
          tooltip = this._viewedTooltip();
          break;
        default:
          tooltip = undefined;
      }
      this.currentTooltip = tooltip;
    }
    _lockedTooltip() {
      if (!this.notificationEventDetail) {
        return undefined;
      }
      if (this.isOrgLimitReached) {
        // global org limit reached  - currently 30 lectures per organization
        return this.getTooltipProps("limit_reached", {
          isOwner: this.isOwner,
          numCourses: this.getOrgNumericSiteStat("num_courses"),
        });
      }
      return this.getTooltipProps("non_video_content_locked", {
        item: this.notificationEventDetail,
        isOwner: this.isOwner,
      });
    }
    _viewedTooltip() {
      const { isFree } = this.notificationEventDetail || {};
      if (isFree) {
        return this.getTooltipProps("preview_lecture_viewed", {
          numAvailable: this.availableLectures,
        });
      }
      return undefined;
    }
  }),
  ((_descriptor = _applyDecoratedDescriptor(
    _class.prototype,
    "availableLectures",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return 1;
      },
    }
  )),
  (_descriptor2 = _applyDecoratedDescriptor(
    _class.prototype,
    "usedLectures",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return 0;
      },
    }
  )),
  (_descriptor3 = _applyDecoratedDescriptor(
    _class.prototype,
    "notificationEvent",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return null;
      },
    }
  )),
  (_descriptor4 = _applyDecoratedDescriptor(
    _class.prototype,
    "notificationEventDetail",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return null;
      },
    }
  )),
  (_descriptor5 = _applyDecoratedDescriptor(
    _class.prototype,
    "ownerName",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return "";
      },
    }
  )),
  (_descriptor6 = _applyDecoratedDescriptor(
    _class.prototype,
    "activeRemainingDays",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return 0;
      },
    }
  )),
  (_descriptor7 = _applyDecoratedDescriptor(
    _class.prototype,
    "currentTooltip",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null,
    }
  )),
  (_descriptor8 = _applyDecoratedDescriptor(
    _class.prototype,
    "isLoading",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return true;
      },
    }
  )),
  (_descriptor9 = _applyDecoratedDescriptor(
    _class.prototype,
    "isOwner",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return false;
      },
    }
  )),
  (_descriptor10 = _applyDecoratedDescriptor(
    _class.prototype,
    "isOrgLimitReached",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return false;
      },
    }
  )),
  (_descriptor11 = _applyDecoratedDescriptor(
    _class.prototype,
    "isNudgeOwnerModalVisible",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return false;
      },
    }
  )),
  (_descriptor12 = _applyDecoratedDescriptor(
    _class.prototype,
    "isLockedLectureModalVisible",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return false;
      },
    }
  )),
  _applyDecoratedDescriptor(
    _class.prototype,
    "toggleOverlay",
    [action],
    Object.getOwnPropertyDescriptor(_class.prototype, "toggleOverlay"),
    _class.prototype
  ),
  (_descriptor13 = _applyDecoratedDescriptor(
    _class.prototype,
    "handleEvent",
    [action],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return async (event) => {
          const { type, detail } = event;
          if (NOTIFICATION_EVENTS.indexOf(type) !== -1) {
            this.notificationEvent = type;
            // save detail in store to be able to use it for tooltips
            this.notificationEventDetail = detail;
            // reset current tooltip
            this.currentTooltip = undefined;
            // refresh the status
            if (!NO_REFRESH_EVENTS.includes(type)) {
              await this.getStatus(true);
            }
          }
        };
      },
    }
  )),
  (_descriptor14 = _applyDecoratedDescriptor(
    _class.prototype,
    "showNudgeOwnerModal",
    [action],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return () => {
          this.isNudgeOwnerModalVisible = true;
        };
      },
    }
  )),
  (_descriptor15 = _applyDecoratedDescriptor(
    _class.prototype,
    "hideNudgeOwnerModal",
    [action],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return () => {
          this.isNudgeOwnerModalVisible = false;
        };
      },
    }
  )),
  (_descriptor16 = _applyDecoratedDescriptor(
    _class.prototype,
    "showLockedLecturesModal",
    [action],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return () => {
          this.isLockedLectureModalVisible = true;
        };
      },
    }
  )),
  (_descriptor17 = _applyDecoratedDescriptor(
    _class.prototype,
    "hideLockedLecturesModal",
    [action],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return () => {
          this.isLockedLectureModalVisible = false;
        };
      },
    }
  ))),
  _class);
//# sourceMappingURL=limited-consumption-trial.mobx-store.js.map
