import _initializerDefineProperty from "@babel/runtime/helpers/initializerDefineProperty";
import _applyDecoratedDescriptor from "@babel/runtime/helpers/applyDecoratedDescriptor";
import _initializerWarningHelper from "@babel/runtime/helpers/initializerWarningHelper";
var _class,
  _descriptor,
  _descriptor2,
  _descriptor3,
  _descriptor4,
  _descriptor5,
  _descriptor6;
import { action, observable } from "mobx";
import { captureException } from "@udemy/sentry";
import { udApi } from "@udemy/ud-api";
import { ActivityNotificationModel } from "./activity-notification.mobx-model";
import { PAGE_SIZE, RELATION_TYPES } from "./constants";
const TabNames = ["instructor", "student"];
const createInitialTabState = () => {
  // `loadingState`: 'NOT_LOADED' initially, 'LOADING' if a request is in progress,
  // 'LOADED' if at least one page of notifications has been loaded.
  //
  // `notifications`: the notification objects that have been loaded thus far.
  // We load notifications in sequential page order. The next page of notifications
  // gets appended to the array.
  //
  // `page`: the current page number.
  //
  // `totalActivitiesCount`: the total number of *activities*, not the total number of
  // notifications. Activities are grouped- each `notification` in the `notifications`
  // array has an `activities` array which contains at least one activity.
  //
  // `unreadActivitiesCount`: the total number of unread *activities*.
  //
  // `_invalidActivitiesCount` and `_invalidUnreadActivitiesCount`: how many invalid
  // activities we've received from the API. We use these to correct `totalActivitiesCount`
  // and `unreadActivitiesCount`, respectively.
  return {
    _invalidActivitiesCount: 0,
    _invalidUnreadActivitiesCount: 0,
    hasNextPage: true,
    loadingState: "NOT_LOADED",
    notifications: [],
    page: 0,
    totalActivitiesCount: 0,
    unreadActivitiesCount: 0,
  };
};
export let ActivityNotificationsStore =
  ((_class = class ActivityNotificationsStore {
    constructor(i18nApi) {
      _initializerDefineProperty(this, "activeTabName", _descriptor, this);
      _initializerDefineProperty(this, "instructor", _descriptor2, this);
      _initializerDefineProperty(this, "student", _descriptor3, this);
      _initializerDefineProperty(this, "user", _descriptor4, this);
      _initializerDefineProperty(this, "userType", _descriptor5, this);
      this.i18nApi = void 0;
      _initializerDefineProperty(
        this,
        "initializeNotifications",
        _descriptor6,
        this
      );
      this.i18nApi = i18nApi;
    }
    setUserSpecificContext(params) {
      this.user = params.user;
      this.setNavUserType(params.userType);
      this.activeTabName = null;
      this.instructor = createInitialTabState();
      this.student = createInitialTabState();
    }
    setNavUserType(userType) {
      this.userType = userType;
    }
    get editNotificationsURL() {
      if (this.userType === "instructor") {
        return "/instructor/account/notifications/";
      }
      return "/user/edit-notifications/";
    }
    get viewNotificationsURL() {
      if (this.userType === "instructor") {
        return "/instructor/user/view-notifications/";
      }
      return "/user/view-notifications/";
    }
    setActiveTab(tabName) {
      this.activeTabName = tabName;
    }
    loadNextPageOfNotifications(tabName) {
      const tab = this[tabName];
      if (tab.loadingState === "LOADING") {
        return;
      }
      this._requestNotifications(tabName, tab)
        .then((response) => {
          this._requestNotificationsSuccess(tab, response);
        })
        .catch((error) => {
          this._requestNotificationsError(tab, error);
        });
    }
    _requestNotifications(tabName, tab, params) {
      tab.loadingState = "LOADING";
      return udApi.get("/users/me/notifications/", {
        params: {
          page: tab.page + 1,
          page_size: PAGE_SIZE,
          relation_type: RELATION_TYPES[tabName],
          "fields[actstream_action]":
            "actor,target,action_object,timestamp,text,is_read",
          "fields[course_discussion]": "@min,title",
          "fields[user]": "@min,image_100x100,initials",
          ...params,
        },
      });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _requestNotificationsSuccess(tab, response) {
      const results = response.data.results || [];
      const count = response.data.count || 0;
      const unreadCount = response.data.unread_count || 0;
      const modelArray = results
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        .map((data) => new ActivityNotificationModel(data, this.i18nApi));
      modelArray.forEach((notification) => {
        if (notification.isValid) {
          tab.notifications.push(notification);
        } else {
          tab._invalidActivitiesCount += notification.activities.length;
          if (!notification.isRead) {
            tab._invalidUnreadActivitiesCount += notification.activities.length;
          }
        }
      });
      tab.page += 1;
      tab.hasNextPage = !!response.data.next;
      tab.totalActivitiesCount = Math.max(
        count - tab._invalidActivitiesCount,
        0
      );
      tab.unreadActivitiesCount = Math.max(
        unreadCount - tab._invalidUnreadActivitiesCount,
        0
      );
      this._updateUnreadCountForAllTabs();
      tab.loadingState = "LOADED";
    }
    _requestNotificationsError(tab, error) {
      tab.loadingState = "LOADED";
      captureException(error);
    }
    markNotificationAsRead(notification, tabName) {
      var _this$tabName;
      const ids = notification.activities.map((activity) => activity.id);
      const deltaUnreadCount = Math.min(
        (_this$tabName = this[tabName]) === null || _this$tabName === void 0
          ? void 0
          : _this$tabName.unreadActivitiesCount,
        ids.length
      );
      notification.setIsRead(true);
      this._updateUnreadCountForTab(tabName, -deltaUnreadCount);
      let apiPromise;
      if (ids.length > 1) {
        apiPromise = udApi.patch("/users/me/notifications/", {
          ids,
          is_read: "True",
          relation_type: RELATION_TYPES[tabName],
        });
      } else if (ids.length === 1) {
        apiPromise = udApi.patch(`/users/me/notifications/${ids[0]}/`, {
          is_read: "True",
          relation_type: RELATION_TYPES[tabName],
        });
      } else {
        // This can never happen- `notification.isValid` is only true if it has at least
        // one activity, and we only push a notification to `tab.notifications` if it is valid.
        throw new Error("Invalid notification with zero activities");
      }
      apiPromise.catch(
        action((error) => {
          notification.setIsRead(false);
          this._updateUnreadCountForTab(tabName, deltaUnreadCount);
          captureException(error);
        })
      );
    }
    markAllNotificationsAsRead(tabName) {
      const tab = this[tabName];
      const unreadNotifications = tab.notifications.filter(
        (notification) => !notification.isRead
      );
      unreadNotifications.forEach((notification) => {
        notification.setIsRead(true);
      });
      const deltaUnreadCount = Math.min(
        tab.unreadActivitiesCount,
        unreadNotifications.reduce(
          (acc, curr) => acc + curr.activities.length,
          0
        )
      );
      this._updateUnreadCountForTab(tabName, -deltaUnreadCount);
      udApi
        .patch("/users/me/notifications/", {
          ids: "all",
          is_read: "True",
          relation_type: RELATION_TYPES[tabName],
        })
        .catch(
          action((error) => {
            unreadNotifications.forEach((notification) => {
              notification.setIsRead(false);
            });
            this._updateUnreadCountForTab(tabName, deltaUnreadCount);
            captureException(error);
          })
        );
    }
    _updateUnreadCountForTab(tabName, delta) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      this[tabName].unreadActivitiesCount += delta;
      this._updateUnreadCountForAllTabs();
    }
    _updateUnreadCountForAllTabs() {
      // This updates `this.user.num_of_unread_activity_notifications` to be the sum of
      // unread instructor activities and unread student activities. It should be called
      // every time we mark a notification as read. Note that currently marking a notification
      // as unread isn't supported. `num_of_unread_activity_notifications` is passed from Django
      // via data-module-args so that we can display it without making API calls for the actual
      // notifications. Hence, it can't be an @computed property.
      if (this.user) {
        this.user.num_of_unread_activity_notifications = TabNames.map(
          (tabName) => this[tabName]
        )
          .filter((tab) => !!tab)
          .reduce((acc, curr) => {
            return (
              acc +
              (curr === null || curr === void 0
                ? void 0
                : curr.unreadActivitiesCount)
            );
          }, 0);
      }
    }
  }),
  ((_descriptor = _applyDecoratedDescriptor(
    _class.prototype,
    "activeTabName",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return null;
      },
    }
  )),
  (_descriptor2 = _applyDecoratedDescriptor(
    _class.prototype,
    "instructor",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null,
    }
  )),
  (_descriptor3 = _applyDecoratedDescriptor(
    _class.prototype,
    "student",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null,
    }
  )),
  (_descriptor4 = _applyDecoratedDescriptor(
    _class.prototype,
    "user",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return null;
      },
    }
  )),
  (_descriptor5 = _applyDecoratedDescriptor(
    _class.prototype,
    "userType",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return null;
      },
    }
  )),
  _applyDecoratedDescriptor(
    _class.prototype,
    "setUserSpecificContext",
    [action],
    Object.getOwnPropertyDescriptor(_class.prototype, "setUserSpecificContext"),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "setNavUserType",
    [action],
    Object.getOwnPropertyDescriptor(_class.prototype, "setNavUserType"),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "setActiveTab",
    [action],
    Object.getOwnPropertyDescriptor(_class.prototype, "setActiveTab"),
    _class.prototype
  ),
  (_descriptor6 = _applyDecoratedDescriptor(
    _class.prototype,
    "initializeNotifications",
    [action],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return () => {
          const promises = [];
          const successes = {};
          const errors = {};
          TabNames.forEach((tabName) => {
            const tab = this[tabName];
            if (tab && tab.loadingState === "NOT_LOADED") {
              const requestPromise = this._requestNotifications(tabName, tab, {
                with_empty_state: "1",
              })
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                .then((response) => {
                  successes[tabName] = response;
                  return response;
                })
                .catch((error) => {
                  errors[tabName] = error;
                });
              promises.push(requestPromise);
            }
          });
          if (promises.length > 0) {
            Promise.all(promises)
              .then(
                action(() => {
                  // We do this in one action so that there aren't any flickering effects when
                  // updating the total number of unread notifications.
                  Object.entries(successes).forEach((_ref) => {
                    let [tabName, response] = _ref;
                    if (response.data.empty_state === "NONE") {
                      this[tabName] = null;
                    } else {
                      this._requestNotificationsSuccess(
                        this[tabName],
                        response
                      );
                    }
                  });
                  Object.entries(errors).forEach((_ref2) => {
                    let [tabName, error] = _ref2;
                    this._requestNotificationsError(this[tabName], error);
                  });
                  if (this.instructor) {
                    this.activeTabName = "instructor";
                  } else if (this.student) {
                    this.activeTabName = "student";
                  }
                })
              )
              .catch((e) => {
                captureException(e);
              });
          }
        };
      },
    }
  )),
  _applyDecoratedDescriptor(
    _class.prototype,
    "loadNextPageOfNotifications",
    [action],
    Object.getOwnPropertyDescriptor(
      _class.prototype,
      "loadNextPageOfNotifications"
    ),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "_requestNotificationsSuccess",
    [action],
    Object.getOwnPropertyDescriptor(
      _class.prototype,
      "_requestNotificationsSuccess"
    ),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "_requestNotificationsError",
    [action],
    Object.getOwnPropertyDescriptor(
      _class.prototype,
      "_requestNotificationsError"
    ),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "markNotificationAsRead",
    [action],
    Object.getOwnPropertyDescriptor(_class.prototype, "markNotificationAsRead"),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "markAllNotificationsAsRead",
    [action],
    Object.getOwnPropertyDescriptor(
      _class.prototype,
      "markAllNotificationsAsRead"
    ),
    _class.prototype
  )),
  _class);
//# sourceMappingURL=activity-notifications.mobx-store.js.map
