import { generateTrackingId, Tracker } from "@udemy/event-tracking";
import {
  DiscoveryItemClickEvent,
  DiscoveryItemImpressionEvent,
  DiscoveryUnitViewEvent,
} from "./events";
// Holding tracking ids of already seen objects so
// we don't track them twice
const alreadyTrackedUUIDs = new Set();
function trackDiscoveryImpression(_ref, _ref2) {
  var _item$frontendTrackin, _ref3, _item$badges, _item$type, _item$tracking_id;
  let { item } = _ref;
  let { backendSource, index, uiRegion } = _ref2;
  let { relatedSourceId = null, relatedSourceType = null } =
    arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  // Adapter for use with TrackImpression wrapper
  // TODO: We should only use frontendTrackingId
  const trackingIdInUse =
    (_item$frontendTrackin = item.frontendTrackingId) !== null &&
    _item$frontendTrackin !== void 0
      ? _item$frontendTrackin
      : item.tracking_id;
  if (trackingIdInUse && alreadyTrackedUUIDs.has(trackingIdInUse)) {
    return;
  }
  const badgeFamilies = item.visibleBadgeFamilies
    ? item.visibleBadgeFamilies
    : (_ref3 =
        (_item$badges = item.badges) === null || _item$badges === void 0
          ? void 0
          : _item$badges.map((b) => b.badge_family)) !== null &&
      _ref3 !== void 0
    ? _ref3
    : null;
  Tracker.publishEvent(
    new DiscoveryItemImpressionEvent({
      id: item.id,
      type: item._class
        ? item._class
        : (_item$type = item.type) !== null && _item$type !== void 0
        ? _item$type
        : "",
      trackingId:
        trackingIdInUse !== null && trackingIdInUse !== void 0
          ? trackingIdInUse
          : "",
      serveTrackingId:
        (_item$tracking_id = item.tracking_id) !== null &&
        _item$tracking_id !== void 0
          ? _item$tracking_id
          : "",
      backendSource,
      position: (index !== null && index !== void 0 ? index : 0) + 1,
      badgeFamilies,
      relatedSourceId,
      relatedSourceType,
      uiRegion,
    })
  );
  trackingIdInUse && alreadyTrackedUUIDs.add(trackingIdInUse);
}
function trackDiscoveryItemClickEvent(_ref4, trackingContext) {
  var _item$frontendTrackin2,
    _ref5,
    _item$badges2,
    _item$type2,
    _item$tracking_id2,
    _trackingContext$inde;
  let { item } = _ref4;
  const trackingId =
    (_item$frontendTrackin2 = item.frontendTrackingId) !== null &&
    _item$frontendTrackin2 !== void 0
      ? _item$frontendTrackin2
      : item.tracking_id;
  const badgeFamilies = item.visibleBadgeFamilies
    ? item.visibleBadgeFamilies
    : (_ref5 =
        (_item$badges2 = item.badges) === null || _item$badges2 === void 0
          ? void 0
          : _item$badges2.map((b) => b.badge_family)) !== null &&
      _ref5 !== void 0
    ? _ref5
    : null;
  Tracker.publishEvent(
    new DiscoveryItemClickEvent({
      id: item.id,
      type: item._class
        ? item._class
        : (_item$type2 = item.type) !== null && _item$type2 !== void 0
        ? _item$type2
        : "",
      trackingId:
        trackingId !== null && trackingId !== void 0 ? trackingId : "",
      serveTrackingId:
        (_item$tracking_id2 = item.tracking_id) !== null &&
        _item$tracking_id2 !== void 0
          ? _item$tracking_id2
          : "",
      backendSource: trackingContext.backendSource,
      position:
        ((_trackingContext$inde = trackingContext.index) !== null &&
        _trackingContext$inde !== void 0
          ? _trackingContext$inde
          : 0) + 1,
      badgeFamilies,
      uiRegion: trackingContext.uiRegion,
    })
  );
}
function trackUnitView(unit, renderType) {
  if (alreadyTrackedUUIDs.has(unit.tracking_id)) {
    return;
  }
  Tracker.publishEvent(
    new DiscoveryUnitViewEvent({
      trackingId: unit.tracking_id,
      unitTitle: unit.title,
      renderType,
    })
  );
  alreadyTrackedUUIDs.add(unit.tracking_id);
}

/**
 * Tracks auto-complete items viewed by the user
 * @param {string} trackingId tracking id for impression event
 * @returns AutoCompleteResultsEvent | null
 */

export const discoveryTracker = {
  alreadyTrackedUUIDs,
  trackDiscoveryImpression,
  trackDiscoveryItemClickEvent,
  trackUnitView,
};
export function attachFrontendTrackingIds(items) {
  // Utility method for attaching frontend tracking IDs to data from APIs
  items
    // We don't want to regenerate ID's for the item
    .filter((item) => !item.frontendTrackingId)
    .forEach((item) => {
      item.frontendTrackingId = generateTrackingId();
    });
}
//# sourceMappingURL=tracking.js.map
