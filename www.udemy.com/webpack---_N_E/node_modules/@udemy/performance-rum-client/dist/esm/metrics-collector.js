import { createPerformanceObservers } from "./create-performance-observers";
import { getDeviceInformation } from "./get-device-information";
import { getNavigationTiming } from "./get-navigation-timing";
import { TimeOnPage } from "./time-on-page";
/**
 * Class that tracks summary performance metrics
 */ // eslint-disable-next-line import/prefer-default-export
export class MetricsCollector {
  constructor() {
    let {
      forcePerformanceObserverInitialization = false,
      isPageCached = null,
      isFirstTimeVisitor = null,
      osName = null,
      deviceType = null,
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.finalizeMetrics = null;
    this.isDisconnected = false;
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    this.disconnectObservers = () => {};
    this.collectedPerformanceData = void 0;
    this.timeOnPage = void 0;
    this.observationTimeout = null;
    /**
     * Creates "private" log entry for production audit (data is OK to be public)
     * @param {string} msg
     */
    this.logEvent = (msg) => {
      var _window$udPerformance, _window$udPerformance2;
      /* istanbul ignore next */
      (_window$udPerformance = window.udPerformance) === null ||
      _window$udPerformance === void 0
        ? void 0
        : (_window$udPerformance2 = _window$udPerformance._logs) === null ||
          _window$udPerformance2 === void 0
        ? void 0
        : _window$udPerformance2.push(msg);
    };
    /**
     * Safely disconnect observers and ensure executed only once
     */
    this.safeDisconnectObservers = () => {
      this.disconnectObservers();
      window.clearTimeout(this.observationTimeout);
      window.document.removeEventListener(
        "visibilitychange",
        this.safeDisconnectObservers
      );
      this.isDisconnected = true;
    };
    // Create private log audit trail
    window.udPerformance = window.udPerformance || {};
    window.udPerformance._logs = [];

    // Create "core" navigationTiming data
    this.collectedPerformanceData = {
      marks: [],
      measures: [],
      resources: {},
    };

    // Gather various information about user
    this.collectedPerformanceData.isFirstTimeVisitor = isFirstTimeVisitor;
    this.collectedPerformanceData.osName = osName;
    this.collectedPerformanceData.deviceType = deviceType;
    this.collectedPerformanceData.isPageCached = isPageCached;

    // Gather various information about user device
    getDeviceInformation((metric, data) => {
      Object.assign(this.collectedPerformanceData, {
        [metric]: data,
      });
    });

    // Tracking User Time Spent on Page
    this.timeOnPage = new TimeOnPage();
    this.timeOnPage.initialize();

    // Is the document currently visible?
    const isDocumentVisible = document.visibilityState === "visible";

    // If document is hidden, don't collect performance observer data because it can be unreliable
    // Additionally, if page visibility ever changes, immediately halt performance observers to avoid
    // weird outlier data
    if (isDocumentVisible || forcePerformanceObserverInitialization === true) {
      // Initialize performance observers
      this.disconnectObservers = this.initializeObservers();

      // We are only going to limit collection to 30 seconds max to keep data comparative
      this.observationTimeout = setTimeout(this.safeDisconnectObservers, 30000);
      window.document.addEventListener(
        "visibilitychange",
        this.safeDisconnectObservers
      );
    }
  }
  /**
   * Initializes variety of performance observers to collect metrics
   *
   * @returns None
   */
  initializeObservers() {
    // Collect metrics from a variety of performance observers
    return createPerformanceObservers(
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (entryType, _ref) => {
        let { name, startTime, duration } = _ref;
        if (entryType === "mark") {
          this.collectedPerformanceData.marks.push({
            name,
            startTime,
          });
          this.logEvent(`${entryType}:${name}:${startTime}`);
        }
        if (entryType === "measure") {
          this.collectedPerformanceData.measures.push({
            name,
            startTime,
            duration,
          });
          this.logEvent(`${entryType}:${name}:${startTime}:${duration}`);
        }
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (type, _ref2) => {
        let { count, duration, transferSize } = _ref2;
        Object.assign(this.collectedPerformanceData.resources, {
          [type]: {
            count,
            duration,
            transferSize,
          },
        });
        this.logEvent(`${type}:${count}:${duration}:${transferSize}`);
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (type, data) => {
        Object.assign(this.collectedPerformanceData, {
          [type]: data,
        });
        this.logEvent(`${type}:${data}`);
      }
    );
  }

  /**
   * Returns metrics summary object ready to send to analytics service.  See `.docs/METRICS.md` for full details of
   * returned summary object.
   *
   * @returns {object} - Performance summary object
   */
  getSummary() {
    if (this.observationTimeout) {
      clearTimeout(this.observationTimeout);
      this.observationTimeout = null;
    }
    this.safeDisconnectObservers(); // Finalizes performance observer metrics
    this.timeOnPage.stopTracking(); // Finalizes time on page metrics

    // Create performance summary object
    const collectedPerformanceData = {
      ...this.collectedPerformanceData,
      ...getNavigationTiming(),
      timeOnSite: this.timeOnPage.getActiveTimeOnPage(),
      timeOnSiteAbsolute: this.timeOnPage.getTotalTimeOnPage(),
    };

    // Convert map of resources to array for serialization
    const serializedPerformanceResources = Object.keys(
      collectedPerformanceData.resources
    ).map((k) => {
      return {
        name: k,
        ...collectedPerformanceData.resources[k],
      };
    });
    // We are changing the type of resources here so we need to do unknown conversion
    collectedPerformanceData.resources = serializedPerformanceResources;
    return collectedPerformanceData;
  }
}
//# sourceMappingURL=metrics-collector.js.map
