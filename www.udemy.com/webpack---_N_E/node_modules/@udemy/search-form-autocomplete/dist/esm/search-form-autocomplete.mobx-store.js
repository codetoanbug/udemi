import _initializerDefineProperty from "@babel/runtime/helpers/initializerDefineProperty";
import _applyDecoratedDescriptor from "@babel/runtime/helpers/applyDecoratedDescriptor";
import _initializerWarningHelper from "@babel/runtime/helpers/initializerWarningHelper";
var _dec,
  _class,
  _descriptor,
  _descriptor2,
  _descriptor3,
  _descriptor4,
  _descriptor5,
  _descriptor6,
  _descriptor7,
  _descriptor8,
  _descriptor9,
  _descriptor10,
  _descriptor11;
import axios from "axios";
import { action, computed, observable } from "mobx";
import { udApi } from "@udemy/ud-api";
import { useAutocompleteSuggestionsQuery } from "./graphql/api-platform-graphql";
import { mapGraphqlResultsToAutocompleteResults } from "./graphql/graphql-results-util";

/**
 * Represents load state of store
 */
export const AUTOSUGGEST_LOADING_STATE = {
  NOT_LOADED: "NOT_LOADED",
  LOADING: "LOADING",
  LOADED: "LOADED",
};

/**
 * Represents params for SearchFormAutoCompleteStore
 */

/**
 * Represents AutoCompleteResult produced by SearchFormAutoCompleteStore
 */

/**
 * Returns localized label for given result type
 */
const getLocalizedResultLabel = (type, gettext) => {
  if (type === "course") {
    return gettext("Course");
  } else if (type === "user") {
    return gettext("Instructor");
  }
  return null;
};

/**
 * Determines aria label for given auto complete result
 */
const getAriaLabelForResult = (result, gettext) => {
  const labelArray = [];
  if (result.type === "search_log") {
    labelArray.push(gettext("Search"), ": ", result.label);
  } else if (result.type === "course") {
    labelArray.push(
      getLocalizedResultLabel(result.type, gettext),
      ": ",
      result.label
    );
    if (result.instructor_name && result.instructor_name.length > 0) {
      labelArray.push(
        " - ",
        getLocalizedResultLabel("user", gettext),
        ": ",
        result.instructor_name
      );
    }
  } else {
    labelArray.push(
      getLocalizedResultLabel("user", gettext),
      ": ",
      result.display_name
    );
  }
  return labelArray.join("");
};

// Default exception handler
const defaultHandleException = (e) => {
  // eslint-disable-next-line no-console
  console.error(e);
};
export let SearchFormAutocompleteStore =
  ((_dec = observable.ref),
  ((_class = class SearchFormAutocompleteStore {
    constructor(params) {
      var _params$getAPIParams,
        _params$getFormParams,
        _params$searchFormExp,
        _params$isPopularQuer;
      this._cancelSource = void 0;
      this._getAPIParams = void 0;
      this._getFormParams = void 0;
      this._suggestTimeoutId = void 0;
      this._url = void 0;
      this.gettext = void 0;
      _initializerDefineProperty(this, "inputValue", _descriptor, this);
      _initializerDefineProperty(this, "isMenuOpen", _descriptor2, this);
      _initializerDefineProperty(
        this,
        "isPopularQueriesExperimentEnabled",
        _descriptor3,
        this
      );
      _initializerDefineProperty(this, "loadingState", _descriptor4, this);
      _initializerDefineProperty(
        this,
        "searchFormExperimentFeatures",
        _descriptor5,
        this
      );
      _initializerDefineProperty(
        this,
        "selectedSuggestionIndex",
        _descriptor6,
        this
      );
      _initializerDefineProperty(this, "suggestionsCount", _descriptor7, this);
      _initializerDefineProperty(this, "suggestions", _descriptor8, this);
      this.cachedSuggestions = {};
      this.captureException = void 0;
      this.maxInputLength = 200;
      this.minInputLength = 2;
      this.suggestTimeout = 200;
      this._loadSuggestions = async () => {
        this._cancelSource = new AbortController();
        try {
          await this.loadSuggestions({
            q: this.query,
            signal: this._cancelSource.signal,
          });
        } catch (e) {
          const isAborted =
            axios.isCancel(e) ||
            (e === null || e === void 0 ? void 0 : e.name) === "AbortError";
          // We do not have to send the AbortError to the sentry
          !isAborted &&
            (e === null || e === void 0 ? void 0 : e.message) &&
            this.captureException(e);
          !isAborted && this.setSuggestions([]);
        }
      };
      _initializerDefineProperty(this, "openMenu", _descriptor9, this);
      _initializerDefineProperty(this, "closeMenu", _descriptor10, this);
      _initializerDefineProperty(this, "clearInputValue", _descriptor11, this);
      // Required: url of the Elasticsearch API.
      this._url = params.url;
      this.captureException = params.captureException || defaultHandleException;

      // Optional: a function that returns params to query the Elasticsearch API with.
      // The search phrase is already included.
      this._getAPIParams =
        (_params$getAPIParams = params.getAPIParams) !== null &&
        _params$getAPIParams !== void 0
          ? _params$getAPIParams
          : null;
      this._getFormParams =
        (_params$getFormParams = params.getFormParams) !== null &&
        _params$getFormParams !== void 0
          ? _params$getFormParams
          : () => ({});
      this.gettext = params.gettext;
      this.searchFormExperimentFeatures =
        (_params$searchFormExp = params.searchFormExperimentFeatures) !==
          null && _params$searchFormExp !== void 0
          ? _params$searchFormExp
          : {};
      this.isPopularQueriesExperimentEnabled =
        (_params$isPopularQuer = params.isPopularQueriesExperimentEnabled) !==
          null && _params$isPopularQuer !== void 0
          ? _params$isPopularQuer
          : false;
      this.suggestions = [];
      if (params.inputValue) {
        this.inputValue = params.inputValue;
      }
    }
    get selectedSuggestion() {
      return this.suggestions[this.selectedSuggestionIndex] || undefined;
    }
    get query() {
      if (this.searchPhrase) {
        return this.searchPhrase
          .trim()
          .substring(0, this.maxInputLength)
          .trim();
      }
      return "";
    }

    /**
     * getter to determine if popular queries should be retrieved
     */
    get shouldLoadPopularQueries() {
      var _this$inputValue;
      return (
        this.isPopularQueriesExperimentEnabled &&
        ((_this$inputValue = this.inputValue) !== null &&
        _this$inputValue !== void 0
          ? _this$inputValue
          : ""
        ).length === 0
      );
    }
    get searchPhrase() {
      return this.selectedSuggestion
        ? this.selectedSuggestion.label
        : this.inputValue;
    }

    /**
     * Get tracking id for current set of suggestions
     */
    get trackingId() {
      return this.suggestions.length > 0
        ? this.suggestions[0].result_tracking_id
        : null;
    }
    async loadSuggestions(params) {
      const results = this.searchFormExperimentFeatures
        .getAutocompleteSuggestionsWithGQL
        ? await this.loadSuggestionsWithGQL(params)
        : await this.loadSuggestionsWithRest(params);
      this._processResults(params.q, results);
    }
    async loadSuggestionsWithRest(_ref) {
      var _response$data$result, _response$data;
      let { q, signal } = _ref;
      const params = this._getAPIParams ? this._getAPIParams() : {};
      const response = await udApi.get(this._url, {
        signal,
        params: {
          q,
          ...params,
        },
      });
      const results =
        (_response$data$result =
          response === null || response === void 0
            ? void 0
            : (_response$data = response.data) === null ||
              _response$data === void 0
            ? void 0
            : _response$data.results) !== null &&
        _response$data$result !== void 0
          ? _response$data$result
          : [];
      (results !== null && results !== void 0 ? results : []).forEach(
        (result) => {
          var _ref2, _result$type, _ref3, _result$label, _result$link;
          result.type =
            (_ref2 =
              (_result$type = result.type) !== null && _result$type !== void 0
                ? _result$type
                : result._class) !== null && _ref2 !== void 0
              ? _ref2
              : null;
          result.label =
            (_ref3 =
              (_result$label = result.label) !== null &&
              _result$label !== void 0
                ? _result$label
                : result.phrase) !== null && _ref3 !== void 0
              ? _ref3
              : result.title;
          result.link =
            (_result$link = result.link) !== null && _result$link !== void 0
              ? _result$link
              : result.url;
        }
      );
      return results;
    }
    async loadSuggestionsWithGQL(param) {
      const params = {
        searchedPhrase: param.q,
      };
      let results = [];
      try {
        var _response$searchAutoc;
        const response = await useAutocompleteSuggestionsQuery.fetcher(params, {
          _signal: param.signal,
        })();
        results =
          (_response$searchAutoc = response.searchAutocomplete) !== null &&
          _response$searchAutoc !== void 0
            ? _response$searchAutoc
            : [];
      } catch (e) {
        // fetch library throwing AbortError when we call the abort(). We need to manually handle this
        if (e.name !== "AbortError") {
          throw e;
        }
      }
      return mapGraphqlResultsToAutocompleteResults(results);
    }
    _processResults(q, response) {
      var _response$length;
      this.suggestionsCount =
        (_response$length =
          response === null || response === void 0
            ? void 0
            : response.length) !== null && _response$length !== void 0
          ? _response$length
          : 0;
      const suggestions = new Array();
      (response !== null && response !== void 0 ? response : []).forEach(
        (result) => {
          var _this$_getFormParams;
          result.ariaLabel = getAriaLabelForResult(result, this.gettext);
          if (!result.label || !result.link) {
            return;
          }
          const [path, queryString] = result.link.split("?");
          const searchParams = new URLSearchParams(queryString);
          const formParams =
            (_this$_getFormParams = this._getFormParams) === null ||
            _this$_getFormParams === void 0
              ? void 0
              : _this$_getFormParams.call(this);
          for (const param in formParams) {
            searchParams.set(param, formParams[param]);
          }
          searchParams.set("src", "sac");
          q && searchParams.set("kw", q);
          result.link = `${path}?${searchParams.toString()}`;
          suggestions.push(result);
        }
      );
      this.setSuggestions(suggestions);
      if (q.length !== 0) {
        Object.assign(this.cachedSuggestions, {
          [q]: suggestions,
        });
      }
    }
    setSearchFormExperimentFeatures(features) {
      this.searchFormExperimentFeatures = features;
    }
    setInputValue(value) {
      this.inputValue = value;
    }

    /**
     * Checks for desired min input length before calling for popular queries
     * @param inputValue input value for popular queries
     */
    async suggest(inputValue) {
      var _this$_cancelSource;
      this.setInputValue(inputValue);
      this.minInputLength = this.shouldLoadPopularQueries ? -1 : 2;
      this.query.length >= this.minInputLength && this.openMenu();
      this.selectedSuggestionIndex = -1;
      this.loadingState = AUTOSUGGEST_LOADING_STATE.LOADING;
      this._suggestTimeoutId !== undefined &&
        clearTimeout(this._suggestTimeoutId);
      (_this$_cancelSource = this._cancelSource) === null ||
      _this$_cancelSource === void 0
        ? void 0
        : _this$_cancelSource.abort();
      this._suggestTimeoutId = this._cancelSource = undefined;
      if (this.query.length < this.minInputLength) {
        this.setSuggestions([]);
      } else if (this.query in this.cachedSuggestions) {
        this.setSuggestions(this.cachedSuggestions[this.query]);
      } else if (this.suggestTimeout !== null) {
        this._suggestTimeoutId = setTimeout(
          this._loadSuggestions,
          this.suggestTimeout
        );
      } else {
        this._loadSuggestions();
      }
    }
    setSuggestions(suggestions) {
      this.suggestions = suggestions;
      this.selectedSuggestionIndex = -1;
      this.loadingState = AUTOSUGGEST_LOADING_STATE.LOADED;
    }
    selectPreviousSuggestion() {
      if (this.suggestions.length > 0) {
        this.openMenu();
        if (this.selectedSuggestionIndex < 0) {
          this.selectedSuggestionIndex = this.suggestions.length - 1;
        } else {
          this.selectedSuggestionIndex -= 1;
        }
      }
    }
    selectNextSuggestion() {
      if (this.suggestions.length > 0) {
        this.openMenu();
        if (this.selectedSuggestionIndex >= this.suggestions.length - 1) {
          this.selectedSuggestionIndex = -1;
        } else {
          this.selectedSuggestionIndex += 1;
        }
      }
    }
    selectSuggestion(index, onSelected) {
      this.selectedSuggestionIndex = index;
      onSelected === null || onSelected === void 0
        ? void 0
        : onSelected(this.selectedSuggestion);
      this.selectedSuggestionIndex = -1;
      this.isMenuOpen = false;
    }
  }),
  ((_descriptor = _applyDecoratedDescriptor(
    _class.prototype,
    "inputValue",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return "";
      },
    }
  )),
  (_descriptor2 = _applyDecoratedDescriptor(
    _class.prototype,
    "isMenuOpen",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return false;
      },
    }
  )),
  (_descriptor3 = _applyDecoratedDescriptor(
    _class.prototype,
    "isPopularQueriesExperimentEnabled",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null,
    }
  )),
  (_descriptor4 = _applyDecoratedDescriptor(
    _class.prototype,
    "loadingState",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return AUTOSUGGEST_LOADING_STATE.NOT_LOADED;
      },
    }
  )),
  (_descriptor5 = _applyDecoratedDescriptor(
    _class.prototype,
    "searchFormExperimentFeatures",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null,
    }
  )),
  (_descriptor6 = _applyDecoratedDescriptor(
    _class.prototype,
    "selectedSuggestionIndex",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return -1;
      },
    }
  )),
  (_descriptor7 = _applyDecoratedDescriptor(
    _class.prototype,
    "suggestionsCount",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return 0;
      },
    }
  )),
  (_descriptor8 = _applyDecoratedDescriptor(
    _class.prototype,
    "suggestions",
    [_dec],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [];
      },
    }
  )),
  _applyDecoratedDescriptor(
    _class.prototype,
    "selectedSuggestion",
    [computed],
    Object.getOwnPropertyDescriptor(_class.prototype, "selectedSuggestion"),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "query",
    [computed],
    Object.getOwnPropertyDescriptor(_class.prototype, "query"),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "shouldLoadPopularQueries",
    [computed],
    Object.getOwnPropertyDescriptor(
      _class.prototype,
      "shouldLoadPopularQueries"
    ),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "searchPhrase",
    [computed],
    Object.getOwnPropertyDescriptor(_class.prototype, "searchPhrase"),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "_processResults",
    [action],
    Object.getOwnPropertyDescriptor(_class.prototype, "_processResults"),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "setSearchFormExperimentFeatures",
    [action],
    Object.getOwnPropertyDescriptor(
      _class.prototype,
      "setSearchFormExperimentFeatures"
    ),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "setInputValue",
    [action],
    Object.getOwnPropertyDescriptor(_class.prototype, "setInputValue"),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "suggest",
    [action],
    Object.getOwnPropertyDescriptor(_class.prototype, "suggest"),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "setSuggestions",
    [action],
    Object.getOwnPropertyDescriptor(_class.prototype, "setSuggestions"),
    _class.prototype
  ),
  (_descriptor9 = _applyDecoratedDescriptor(
    _class.prototype,
    "openMenu",
    [action],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return () => {
          this.isMenuOpen = true;
        };
      },
    }
  )),
  (_descriptor10 = _applyDecoratedDescriptor(
    _class.prototype,
    "closeMenu",
    [action],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return () => {
          this.isMenuOpen = false;
          this.selectedSuggestionIndex = -1;
        };
      },
    }
  )),
  _applyDecoratedDescriptor(
    _class.prototype,
    "selectPreviousSuggestion",
    [action],
    Object.getOwnPropertyDescriptor(
      _class.prototype,
      "selectPreviousSuggestion"
    ),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "selectNextSuggestion",
    [action],
    Object.getOwnPropertyDescriptor(_class.prototype, "selectNextSuggestion"),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "selectSuggestion",
    [action],
    Object.getOwnPropertyDescriptor(_class.prototype, "selectSuggestion"),
    _class.prototype
  ),
  (_descriptor11 = _applyDecoratedDescriptor(
    _class.prototype,
    "clearInputValue",
    [action],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return () => {
          this.inputValue = "";
          this.setSuggestions([]);
          this.isMenuOpen = false;
        };
      },
    }
  ))),
  _class));
//# sourceMappingURL=search-form-autocomplete.mobx-store.js.map
