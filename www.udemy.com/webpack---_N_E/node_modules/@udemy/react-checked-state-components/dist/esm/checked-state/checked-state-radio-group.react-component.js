import React, {
  createContext,
  useContext,
  useEffect,
  useState,
  useRef,
} from "react";
import { CheckedState } from "./checked-state.react-component";
/** React Context Interface for the CheckedState Radio Group */

const RadioGroupContext = /*#__PURE__*/ createContext(null);
/** React props interface for the `CheckedStateRadioGroup` */

/** The CheckedStateRadioGroup component */
export const CheckedStateRadioGroup = (_ref) => {
  let { allowToggle = false, name, children } = _ref;
  const [selectedId, setSelectedId] = useState(null);
  const context = {
    allowToggle,
    selectedId,
    setSelectedId,
    name,
  };
  return /*#__PURE__*/ React.createElement(
    RadioGroupContext.Provider,
    {
      value: context,
    },
    children
  );
};
/** The React prop interface for `CheckStateRadioGroup`'s `Radio` component
 *  @internal
 */

/** A Radio component for use within `CheckedStateRadioGroup`
 *  @internal
 *
 *  @remarks
 *  Not exported but available via `CheckedStateRadioGroup.Radio`
 */
const Radio = (_ref2) => {
  let {
    checked = null,
    defaultChecked = false,
    checkedStateComponent: CheckedStateComponent = CheckedState,
    ...props
  } = _ref2;
  // isFirstRender and associated logic replaces call to setSelectedId within
  // a class component constructor. The call needs to run once, and not trigger
  // an immediate re-render for the other Radio components in the group. Tracking
  // isFirstRender with useRef rather than useState prevents undesired re-render.
  const isFirstRender = useRef(true);
  const radioGroup = useContext(RadioGroupContext);
  useEffect(() => {
    if (defaultChecked) {
      radioGroup === null || radioGroup === void 0
        ? void 0
        : radioGroup.setSelectedId(props.id);
    }
    /* eslint-disable react-hooks/exhaustive-deps */
  }, []);

  const onChange = (event) => {
    var _event$target;

    const wasChecked = !!(
      (_event$target = event.target) !== null &&
      _event$target !== void 0 &&
      _event$target.dataset.checked
    );
    const isChecked =
      !(
        radioGroup !== null &&
        radioGroup !== void 0 &&
        radioGroup.allowToggle
      ) || !wasChecked;
    event.target.dataset.checked = isChecked ? "checked" : "";
    radioGroup === null || radioGroup === void 0
      ? void 0
      : radioGroup.setSelectedId(isChecked ? event.target.id : null);

    if (wasChecked !== isChecked) {
      var _props$onChange;

      (_props$onChange = props.onChange) === null || _props$onChange === void 0
        ? void 0
        : _props$onChange.call(props, event);
    }
  };

  const isCheckedByDefault = isFirstRender.current && defaultChecked;
  const isCheckedBySelection =
    (radioGroup === null || radioGroup === void 0
      ? void 0
      : radioGroup.selectedId) === props.id;
  const isChecked =
    checked !== null ? checked : isCheckedByDefault || isCheckedBySelection;
  isFirstRender.current = false;
  return /*#__PURE__*/ React.createElement(
    CheckedStateComponent,
    Object.assign({}, props, {
      "data-type": "radio",
      "data-name":
        radioGroup === null || radioGroup === void 0 ? void 0 : radioGroup.name,
      "data-checked": isChecked ? "checked" : "",
      onChange: onChange,
    })
  );
};

CheckedStateRadioGroup.Radio = Radio;
//# sourceMappingURL=checked-state-radio-group.react-component.js.map
