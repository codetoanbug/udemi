import classNames from "classnames";
import { action } from "mobx";
import { observer } from "mobx-react";
import React from "react";
import { whenBrazeReady } from "@udemy/braze";
import { ClickEvent, Tracker } from "@udemy/event-tracking";
import { useI18n } from "@udemy/i18n";
import { Button } from "@udemy/react-core-components";
import { captureException } from "@udemy/sentry";
import { serverOrClient } from "@udemy/shared-utils";
import { shoppingConfig, couponUrlHandler } from "@udemy/shopping";
import { useUDData } from "@udemy/ud-data";
import { AddToCartEvent, CartErrorDisplayEvent } from "../events";
import { addToCartConfig } from "./config";

// eslint-disable-next-line @typescript-eslint/no-empty-function
function noop() {}
export const Notification = (_ref) => {
  let { notification, notificationStyle } = _ref;
  return /*#__PURE__*/ React.createElement(
    React.Fragment,
    null,
    notification &&
      /*#__PURE__*/ React.createElement(
        "span",
        {
          className: notificationStyle,
        },
        notification
      )
  );
};
export const ButtonInternalState = (_ref2) => {
  let { buttonContent, isAdding, isReady, loader } = _ref2;
  return /*#__PURE__*/ React.createElement(
    React.Fragment,
    null,
    !isReady || (isAdding && loader),
    !isAdding && buttonContent
  );
};
export const GenericAddToCart = observer((_ref3) => {
  let {
    addToCartContext,
    addToCartSuccessModal,
    allowAddToCartSuccessModal = true,
    buttonClass = Button,
    buttonStyleProps = {},
    buyables = [],
    cartButtonClassesAdd = "",
    cartButtonClassesGoToCart = "",
    cartButtonTextAdd,
    cartButtonTextGoToCart,
    disabled = false,
    forceGoToCart = false,
    forceSuccessModalOnMobile = false,
    loader,
    notificationStyle = "",
    onAddRedirectUrl = addToCartConfig.urls.cartPage,
    onRequestFinish = noop,
    onRequestStart = noop,
    shoppingClient,
    showCartSuccessModal = noop,
  } = _ref3;
  const udData = useUDData();
  const { gettext, interpolate, ngettext } = useI18n();
  // instead of @observable isAdding = false;
  const [isAdding, setIsAdding] = React.useState(false);

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const [notification, setNotification] = React.useState(null);
  const [screenreaderMessage, setScreenreaderMessage] = React.useState("");
  function hasBuyables() {
    return !disabled && shoppingClient.lists.cart.hasBuyables(buyables);
  }
  function trackClick() {
    if (hasBuyables()) {
      // Track 'Go to cart' click event -- currently only capturing the first buyable if users
      // select 'Add all to cart' in bundle unit
      const buyable = buyables[0];
      if (buyable) {
        Tracker.publishEvent(
          new ClickEvent({
            componentName: "goToCart",
            trackingId:
              (buyable === null || buyable === void 0
                ? void 0
                : buyable.frontendTrackingId) ||
              (buyable === null || buyable === void 0
                ? void 0
                : buyable.tracking_id),
            relatedObjectId:
              buyable === null || buyable === void 0 ? void 0 : buyable.id,
            relatedObjectType: "course",
          })
        );
      }
      return;
    }
    // TODO Remove conditional logic after making `frontendTrackingId` required.
    let fireEvent = true;
    buyables.forEach((buyable) => {
      if (!buyable.frontendTrackingId && !buyable.tracking_id) {
        fireEvent = false;
      }
    });
    if (fireEvent) {
      Tracker.publishEvent(
        new AddToCartEvent({
          buyables: buyables.map((buyable) => ({
            type: buyable.buyable_object_type,
            id: buyable.id,
            trackingId: buyable.frontendTrackingId || buyable.tracking_id,
          })),
        })
      );
    }
  }
  function sendBrazeEvent() {
    whenBrazeReady((appboy) => {
      const { me: udMe } = udData;
      if (udMe.is_authenticated) {
        return;
      }
      if (appboy.isPushPermissionGranted()) {
        // Only trigger event for the first course added to the cart
        // if the same visitor adds multiple courses to their cart
        if (shoppingClient.lists.cart.isEmpty) {
          const courseInCart = buyables.map((buyable) => {
            return buyable.id;
          });
          appboy.logCustomEvent("UserCartAbandonment", {
            courses_in_cart: courseInCart,
          });
        }
      }
    });
  }
  function goToCart() {
    serverOrClient.global.location.href = addToCartConfig.urls.cartPage;
  }
  function addCodes() {
    const params = new URLSearchParams(serverOrClient.global.location.search);
    const codes = couponUrlHandler(params).get();
    const newCodes = codes.filter(
      (code) => !shoppingClient.discounts.codes.includes(code)
    );
    return new Promise((resolve) => {
      shoppingClient.applyDiscounts(newCodes);
      return resolve(true);
    });
  }
  function onAddSuccess() {
    setIsAdding(false);
    setNotification(null);
    return addCodes();
  }
  function onAddFail() {
    setIsAdding(false);
    setNotification(addToCartConfig.errors(gettext).failAddToCart);
    Tracker.publishEvent(
      new CartErrorDisplayEvent({
        buyables: buyables.map((buyable) => ({
          type: buyable.buyable_object_type,
          id: buyable.id,
          trackingId: buyable.frontendTrackingId,
        })),
        action: "add",
        uiRegion: "add_to_cart",
      })
    );
    onRequestFinish();
    return Promise.reject(new Error("Add to cart failed."));
  }
  function buttonContent() {
    if (hasBuyables()) {
      return cartButtonTextGoToCart || gettext("Go to cart");
    }
    if (
      shoppingClient.status.get() === shoppingConfig.storage.status.unAvailable
    ) {
      return addToCartConfig.errors(gettext).cartUnavailableShort;
    }
    return cartButtonTextAdd || gettext("Add to cart");
  }
  function additionalClassNames() {
    return hasBuyables() ? cartButtonClassesGoToCart : cartButtonClassesAdd;
  }
  function addItems() {
    const { request: udRequest } = udData;
    setIsAdding(true);
    onRequestStart();
    setTimeout(
      action(() => {
        if (isAdding) {
          setNotification(addToCartConfig.errors(gettext).stillWorking);
        }
      }),
      addToCartConfig.timing.addToCartSlow
    );
    return shoppingClient
      .addToList("cart", buyables, addToCartContext)
      .then(onAddSuccess, onAddFail)
      .then(
        action(() => {
          onRequestFinish();
          if (udRequest.isMobile) {
            if (forceSuccessModalOnMobile) {
              showCartSuccessModal();
            } else {
              serverOrClient.global.location.href = onAddRedirectUrl;
            }
          } else if (allowAddToCartSuccessModal) {
            showCartSuccessModal();
          } else {
            setScreenreaderMessage(
              interpolate(
                ngettext(
                  "%(cartCount)s item added to cart.",
                  "%(cartCount)s items added to cart.",
                  buyables.length
                ),
                {
                  cartCount: buyables.length,
                },
                true
              )
            );
            if (forceGoToCart) {
              serverOrClient.global.location.href = onAddRedirectUrl;
            }
          }
        })
      )
      .catch((e) => {
        captureException(e);
      });
  }

  // onClick handler
  function onClick() {
    trackClick();
    sendBrazeEvent();
    return hasBuyables() ? goToCart() : addItems();
  }
  const status = shoppingClient.status.get();
  const isReady = !disabled && status === shoppingConfig.storage.status.ready;
  const isDisabled =
    !isReady ||
    status === shoppingConfig.storage.status.unAvailable ||
    isAdding;
  const buttonInternalState = /*#__PURE__*/ React.createElement(
    ButtonInternalState,
    {
      isReady: isReady,
      isAdding: isAdding,
      buttonContent: buttonContent(),
      loader: loader,
    }
  );
  const buttonProps = {
    "data-testid": "add-to-cart-button",
    // GoogleTagManager code depends on the `.add-to-cart` class for third party paid acquisition
    className: classNames("add-to-cart", additionalClassNames()),
    disabled: isDisabled,
    onClick: onClick,
    style: {
      width: "100%",
    },
    ...buttonStyleProps,
  };
  const button = /*#__PURE__*/ React.createElement(
    buttonClass,
    buttonProps,
    buttonInternalState
  );
  return /*#__PURE__*/ React.createElement(
    "div",
    {
      "data-purpose": "add-to-cart",
    },
    button,
    addToCartSuccessModal,
    /*#__PURE__*/ React.createElement(Notification, {
      notification: notification,
      notificationStyle: notificationStyle,
    }),
    /*#__PURE__*/ React.createElement(
      "div",
      {
        role: "status",
        className: "ud-sr-only",
        "data-purpose": "screen-reader-message",
      },
      screenreaderMessage
    )
  );
});
GenericAddToCart.displayName = "GenericAddToCart";
//# sourceMappingURL=generic-add-to-cart.react-component.js.map
