import _initializerDefineProperty from "@babel/runtime/helpers/initializerDefineProperty";
import _applyDecoratedDescriptor from "@babel/runtime/helpers/applyDecoratedDescriptor";
import _initializerWarningHelper from "@babel/runtime/helpers/initializerWarningHelper";
var _class, _descriptor, _descriptor2, _descriptor3, _class2;
import { observable, action } from "mobx";
import { serverOrClient } from "@udemy/shared-utils";
import { udApi } from "@udemy/ud-api";
const BATCH_SIZE = 10;
export const PRICING_API = "pricing/";
const PRICING_API_FIELDS =
  "price,discount_price,list_price,price_detail,price_serve_tracking_id";

// TODO: Remove once typing is finalized
//updatePriceMap price value - pulled from logging in monolith LOHP
// const priceResult: CoursePriceOrStatus = {
//     discount: {
//         price: {
//             amount: 149,
//             currency: 'MXN',
//             price_string: 'MX$149',
//             currency_symbol: 'MX$',
//         },
//     },
//     discount_price: {
//         amount: 149,
//         currency: 'MXN',
//         price_string: 'MX$149',
//         currency_symbol: 'MX$',
//     },
//     price: 'MX$479',
//     price_detail: {
//         amount: 479,
//         currency: 'MXN',
//         price_string: 'MX$479',
//         currency_symbol: 'MX$',
//     },
//     price_serve_tracking_id: '6VKK6nV1QJicjphhTNg8ZA',
//     status: PriceStatus.PRICE_STATUS_LOADED,
// };

/**
 * === API TYPES ===
 * These types represent the data returned from the pricing API
 * ===
 */
/**
 * === EXTERNAL TYPES ===
 * These types represent the data that is passed into the CoursePriceStore via
 * its public API
 * ===
 */
/**
 * === INTERNAL TYPES ===
 * These types represent the data that is stored inside the CoursePriceStore. They are
 * typically similar to the external types but also account for async loading of prices
 * ===
 */
export let PriceStatus = /*#__PURE__*/ (function (PriceStatus) {
  PriceStatus["PRICE_STATUS_LOADING"] = "loading";
  PriceStatus["PRICE_STATUS_LOADED"] = "loaded";
  PriceStatus["PRICE_STATUS_ERROR"] = "error";
  return PriceStatus;
})({});
/**
 * Loads and caches course prices so that they can be shared across the site.
 * See the above types along with the associated comments for details on how
 * this store handles the various data formats.
 */
export let CoursePriceStore =
  ((_class =
    ((_class2 = class CoursePriceStore {
      constructor() {
        _initializerDefineProperty(this, "priceMap", _descriptor, this);
        _initializerDefineProperty(this, "modelMap", _descriptor2, this);
        this.isLoading = false;
        this._courseIdsToFetch = [];
        this._timeouts = [];
        this.registerCourse = (course, initialPrice) => {
          // Store the original model so we can update it once we get the price (in _updatePriceMap).
          // This is done just for funnel-logging. Once migrate off it, this should be removed.
          this.modelMap.set(+course.id, course);
          const existingPrice = this.priceMap.get(course.id);
          if (
            existingPrice &&
            existingPrice.status !== PriceStatus.PRICE_STATUS_ERROR
          ) {
            return;
          }
          this.setCoursePrice(course.id, initialPrice);
          if (this._courseIdsToFetch.length === 0) {
            this._courseIdsToFetch.push(course.id);
            this._loadCourses();
          } else {
            this._courseIdsToFetch.push(course.id);
          }
        };
        this.reloadCourses = () => {
          // this is used to reload prices in Discovery Units:
          // - in you `You Might Like' in the cart after applying a coupon
          this.priceMap.forEach((price, courseId) => {
            price.status = PriceStatus.PRICE_STATUS_ERROR;
            const course = this.modelMap.get(courseId);
            if (course) {
              this.registerCourse(course);
            }
          });
        };
        this._loadCourses = () => {
          if (serverOrClient.isClient) {
            this.isLoading = true;
            const timeoutId = setTimeout(this.requestInBatches, 250);
            this._timeouts.push(timeoutId);
          }
        };
        this.requestInBatches = () => {
          const sortedCourseIds = this._courseIdsToFetch.sort();
          while (sortedCourseIds.length !== 0) {
            const courseIds = sortedCourseIds.splice(0, BATCH_SIZE);
            udApi
              .get(PRICING_API, {
                params: {
                  course_ids: courseIds.join(","),
                  "fields[pricing_result]": PRICING_API_FIELDS,
                },
              })
              .then(this.updatePriceMap)
              .catch(this.updateErrorState(courseIds));
          }
          this.isLoading = false;
        };
        _initializerDefineProperty(this, "updatePriceMap", _descriptor3, this);
        this.updateErrorState = (courseIds) => {
          return action(() => {
            courseIds.forEach((courseId) => {
              const existingPrice = this.priceMap.get(courseId);
              const newStatus = {
                ...(existingPrice !== null && existingPrice !== void 0
                  ? existingPrice
                  : {}),
                status: PriceStatus.PRICE_STATUS_ERROR,
              };
              this.priceMap.set(courseId, newStatus);
            });
          });
        };
      }
      setCoursePrice(id, price) {
        this.priceMap.set(id, {
          ...(price !== null && price !== void 0 ? price : {}),
          status: PriceStatus.PRICE_STATUS_LOADING,
        });
      }
      reset() {
        // utility for testing
        this.priceMap.clear();
        this.isLoading = false;
        this._courseIdsToFetch = [];
        this._timeouts.forEach((timeoutId) => {
          clearTimeout(timeoutId);
        });
      }
    }),
    (_class2.STORE_ID = "CoursePriceStore"),
    _class2)),
  ((_descriptor = _applyDecoratedDescriptor(
    _class.prototype,
    "priceMap",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return observable.map(
          {},
          {
            name: "priceMap",
            deep: false,
          }
        );
      },
    }
  )),
  (_descriptor2 = _applyDecoratedDescriptor(
    _class.prototype,
    "modelMap",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return observable.map(
          {},
          {
            name: "modelMap",
            deep: false,
          }
        );
      },
    }
  )),
  (_descriptor3 = _applyDecoratedDescriptor(
    _class.prototype,
    "updatePriceMap",
    [action],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return (responseData) => {
          Object.entries(responseData.data.courses).forEach((_ref) => {
            var _priceResult$list_pri;
            let [courseId, priceResult] = _ref;
            const priceObj = {
              discount: {
                price: priceResult.price,
              },
              discount_price: priceResult.discount_price,
              price:
                (_priceResult$list_pri = priceResult.list_price) === null ||
                _priceResult$list_pri === void 0
                  ? void 0
                  : _priceResult$list_pri.price_string,
              price_detail: priceResult.price_detail,
              price_serve_tracking_id: priceResult.price_serve_tracking_id,
              status: PriceStatus.PRICE_STATUS_LOADED,
            };
            const courseIdNumber = parseInt(courseId, 10);
            this.priceMap.set(courseIdNumber, priceObj);
            const courseModel = this.modelMap.get(Number(courseId));
            if (courseModel && courseModel._course) {
              Object.assign(courseModel._course, priceObj);
            }
          });
        };
      },
    }
  )),
  _applyDecoratedDescriptor(
    _class.prototype,
    "setCoursePrice",
    [action],
    Object.getOwnPropertyDescriptor(_class.prototype, "setCoursePrice"),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "reset",
    [action],
    Object.getOwnPropertyDescriptor(_class.prototype, "reset"),
    _class.prototype
  )),
  _class);
//# sourceMappingURL=course-price-store.js.map
