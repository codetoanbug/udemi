import _applyDecoratedDescriptor from "@babel/runtime/helpers/applyDecoratedDescriptor";
var _class, _class2, _class3, _class4;
import autobind from "autobind-decorator";
import classNames from "classnames";
import { observer } from "mobx-react";
import React, { Component } from "react";
import CloseIcon from "@udemy/icons/dist/close.ud-icon";
import DeleteIcon from "@udemy/icons/dist/delete.ud-icon";
import ErrorIcon from "@udemy/icons/dist/error.ud-icon";
import NextIcon from "@udemy/icons/dist/next.ud-icon";
import PreviousIcon from "@udemy/icons/dist/previous.ud-icon";
import ScheduleIcon from "@udemy/icons/dist/schedule.ud-icon";
import SuccessIcon from "@udemy/icons/dist/success.ud-icon";
import { BlockList, Button } from "@udemy/react-core-components";
import { EventStatus } from "../tracker/constants";
import { TrackerDebuggerStore } from "./tracker-debugger.mobx-store";
import styles from "./tracker-debugger.module.css";
const gettext = (t) => t;
export const statusIcons = {
  [EventStatus.WAITING]: {
    label: "Waiting",
    statusIcon: /*#__PURE__*/ React.createElement(ScheduleIcon, {
      label: gettext("Waiting"),
      color: "neutral",
    }),
    textStyle: "subdued",
  },
  [EventStatus.FAILURE]: {
    label: "Failure",
    statusIcon: /*#__PURE__*/ React.createElement(ErrorIcon, {
      label: gettext("Failure"),
      color: "negative",
    }),
    textStyle: "negative",
  },
  [EventStatus.SUCCESS]: {
    label: "Success",
    statusIcon: /*#__PURE__*/ React.createElement(SuccessIcon, {
      label: gettext("Success"),
      color: "positive",
    }),
    textStyle: "positive",
  },
  [EventStatus.BEACON_SENT]: {
    label: "Sent with Beacon API",
    statusIcon: /*#__PURE__*/ React.createElement(SuccessIcon, {
      label: gettext("Sent with Beacon API"),
      color: "neutral",
    }),
    textStyle: "subdued",
  },
};
const beaconInformative =
  "This event was sent with Beacon API on a tab change. " +
  "Beacon API doesn't expose server responses. " +
  "If you want to see the response from Collector, don't switch tabs until this event is sent.";
export let ItemWrapper =
  observer(
    (_class =
      ((_class2 = class ItemWrapper extends Component {
        toggleFocus() {
          // Focus is implemented on Javascript while hover is controlled with CSS
          // Preferred this way because focus on buttons does not work on Firefox:
          // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#clicking_and_focus
          const { eventInfo, store } = this.props;
          const id = eventInfo.event.eventId;
          if (store.focusedItemId === id) {
            store.setFocusedItemId(null);
          } else {
            store.setFocusedItemId(id);
          }
        }
        resetFocus() {
          // We're removing the focus when another element is hovered
          const { eventInfo, store } = this.props;
          const id = eventInfo.event.eventId;
          if (store.focusedItemId && store.focusedItemId !== id) {
            store.setFocusedItemId(null);
          }
        }
        render() {
          const { eventInfo, store } = this.props;
          const { event, status, failureReason } = eventInfo;
          const { label, textStyle, statusIcon } = statusIcons[status];
          return /*#__PURE__*/ React.createElement(
            BlockList.Item,
            {
              componentClass: "button",
              "data-testid": "blocklist-item",
              className: classNames(
                "blocklist-item",
                styles["blocklist-item"],
                event.eventId === store.focusedItemId
                  ? `${styles.focused} focused`
                  : ""
              ),
              style: {
                userSelect: "text",
              },
              icon: statusIcon,
              onClick: this.toggleFocus,
              onMouseEnter: this.resetFocus,
            },
            /*#__PURE__*/ React.createElement(
              "span",
              {
                className: classNames(
                  "ud-heading-sm",
                  styles.subdued,
                  styles["item-text"]
                ),
              },
              event.getType()
            ),
            /*#__PURE__*/ React.createElement(
              "div",
              {
                className: classNames(
                  styles.panel,
                  styles["tooltip-panel"],
                  "tooltip-panel"
                ),
              },
              /*#__PURE__*/ React.createElement(
                "div",
                {
                  className: classNames("ud-heading-md", textStyle),
                },
                `${label}: ${event.getType()}`
              ),
              failureReason &&
                /*#__PURE__*/ React.createElement("h4", null, failureReason),
              status === EventStatus.BEACON_SENT &&
                /*#__PURE__*/ React.createElement(
                  "pre",
                  {
                    className: classNames(
                      "ud-text-xs",
                      styles["tooltip-panel-body"]
                    ),
                  },
                  beaconInformative
                ),
              /*#__PURE__*/ React.createElement(
                "pre",
                {
                  className: classNames(
                    "ud-text-xs",
                    styles["tooltip-panel-body"]
                  ),
                },
                JSON.stringify(event, null, 4)
              )
            )
          );
        }
      }),
      (_applyDecoratedDescriptor(
        _class2.prototype,
        "toggleFocus",
        [autobind],
        Object.getOwnPropertyDescriptor(_class2.prototype, "toggleFocus"),
        _class2.prototype
      ),
      _applyDecoratedDescriptor(
        _class2.prototype,
        "resetFocus",
        [autobind],
        Object.getOwnPropertyDescriptor(_class2.prototype, "resetFocus"),
        _class2.prototype
      )),
      _class2))
  ) || _class;
export let TrackerDebugger =
  observer(
    (_class3 =
      ((_class4 = class TrackerDebugger extends Component {
        constructor(props) {
          super(props);
          this.MAX_EVENTS_TO_SHOW = void 0;
          this.store = void 0;
          this.store = new TrackerDebuggerStore();
          this.MAX_EVENTS_TO_SHOW =
            this.props.isMobile === true
              ? TrackerDebugger.MAX_EVENTS_TO_SHOW_MOBILE
              : TrackerDebugger.MAX_EVENTS_TO_SHOW_DESKTOP;
        }
        render() {
          if (!this.store.isEnabled) {
            return null;
          }
          const { eventInfoStore } = this.props;
          return /*#__PURE__*/ React.createElement(
            "div",
            {
              "data-testid": "tracker-debugger",
              className: classNames(
                styles.panel,
                styles["debugger-panel"],
                this.store.isInvertedPosition
                  ? styles["left-debugger-panel"]
                  : styles["right-debugger-panel"]
              ),
            },
            /*#__PURE__*/ React.createElement(
              "div",
              {
                className: styles["debugger-panel-header"],
              },
              /*#__PURE__*/ React.createElement(
                Button,
                {
                  onClick: this.store.invertPosition,
                  udStyle: "secondary",
                  size: "small",
                  className: styles.control,
                },
                this.store.isInvertedPosition
                  ? /*#__PURE__*/ React.createElement(NextIcon, {
                      color: "inherit",
                      size: "medium",
                      label: gettext("Invert position"),
                    })
                  : /*#__PURE__*/ React.createElement(PreviousIcon, {
                      color: "inherit",
                      size: "medium",
                      label: gettext("Invert position"),
                    })
              ),
              /*#__PURE__*/ React.createElement(
                Button,
                {
                  onClick: eventInfoStore.clearEvents,
                  udStyle: "secondary",
                  size: "small",
                  className: styles.control,
                },
                /*#__PURE__*/ React.createElement(DeleteIcon, {
                  color: "inherit",
                  size: "medium",
                  label: gettext("Clear events"),
                })
              ),
              /*#__PURE__*/ React.createElement(
                Button,
                {
                  onClick: this.store.disable,
                  udStyle: "secondary",
                  size: "small",
                  className: styles.control,
                },
                /*#__PURE__*/ React.createElement(CloseIcon, {
                  color: "inherit",
                  size: "medium",
                  label: gettext("Close debugger"),
                })
              )
            ),
            /*#__PURE__*/ React.createElement(
              BlockList,
              {
                className: classNames(
                  styles["debugger-panel-body"],
                  "debugger-panel-body"
                ),
                size: "small",
              },
              eventInfoStore.eventInfos
                .slice(-this.MAX_EVENTS_TO_SHOW)
                .map((eventInfo) => {
                  return /*#__PURE__*/ React.createElement(ItemWrapper, {
                    key: eventInfo.event.eventId,
                    eventInfo: eventInfo,
                    store: this.store,
                  });
                })
            )
          );
        }
      }),
      (_class4.MAX_EVENTS_TO_SHOW_DESKTOP = 15),
      (_class4.MAX_EVENTS_TO_SHOW_MOBILE = 5),
      _class4))
  ) || _class3;
//# sourceMappingURL=tracker-debugger.react-component.js.map
