import axios from "axios";

// TODO: make sure we capture log error from `triggerCloseListeners()`
// import Raven from 'utils/ud-raven';

import { PageVisibilityChangeEvent } from "../lib/events";
import {
  collectorPath,
  DOMAIN_CONFIG,
  defaultDomain,
  EventStatus,
} from "./constants";
import {
  logError,
  makeRetryingFunction,
  preventOverlappingCall,
} from "./helpers";
import tracker from "./tracker";
export const constants = {
  clientKeyUrlParam: "client_key",
  clientKey: "js",
  clientVersionUrlParam: "client_version",
  queueFlushPeriod: 3000,
  queueInitialFlushDelay: 250,
  requestTimeout: 20000,
  retryGap: 3000,
  maxTimeoutRetry: 3,
};
export const queue = [];
const externalPublishHooks = [];
export function addPublishHook(hook) {
  externalPublishHooks.push(hook);
}
export function resetPublishHooks() {
  externalPublishHooks.splice(0, externalPublishHooks.length);
}
function callExternalPublishHooks(event, status, failureReason) {
  externalPublishHooks.forEach((hook) => {
    hook(event, status, failureReason);
  });
}

// todo make these go away
let send;
let queueFlusher;
let collectorUrl;
let publishHook;

// Store the events being currently sent because they may need to be retried by the beacon API
let eventsInFlight;
const closeListeners = [];
let senderClosed = false;

// Initialized by `initializeSender` and cancelled by `closeSender()` during `pagehide` event
// eslint-disable-next-line @typescript-eslint/no-explicit-any
let queueFlusherInterval;
let _clientKey = constants.clientKey;
let captureExceptionFunc = (ex) => {
  logError(ex);
};
export function initializeSender(publishHook, appVersion, domainConfig) {
  let clientRetries =
    arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  let collectorURLOverride = arguments.length > 4 ? arguments[4] : undefined;
  let clientKey = arguments.length > 5 ? arguments[5] : undefined;
  let disablePageVisibilityTracking =
    arguments.length > 6 ? arguments[6] : undefined;
  let captureException = arguments.length > 7 ? arguments[7] : undefined;
  if (captureException) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    captureExceptionFunc = captureException;
  }
  if (clientKey) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _clientKey = clientKey;
  }
  collectorUrl = _getCollectorUrl(
    appVersion,
    domainConfig,
    collectorURLOverride
  );
  if (publishHook) {
    initializeSenderPublishHook(publishHook);
  }
  const udTrackApi = axios.create({
    timeout: constants.requestTimeout,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    headers: {
      "Content-Type": "text/plain",
    },
  });

  // todo change back to send
  send = makeRetryingFunction(
    (data) => {
      return udTrackApi.post(collectorUrl, data);
    },
    constants.maxTimeoutRetry,
    constants.retryGap,
    _shouldRetryRequest(clientRetries)
  );
  queueFlusher = preventOverlappingCall(_flush);
  _setupBeacon(disablePageVisibilityTracking);
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  queueFlusherInterval = setInterval(() => {
    if (!senderClosed) {
      queueFlusher();
    }
  }, constants.queueFlushPeriod);

  // For being able to flush the initial events waiting for the promise to resolve
  // we manually send them without waiting the first `queueFlushPeriod`.
  // We wait for `queueInitialFlushDelay` before sending this first batch to
  // allow initial events to proceed on their resolved promises.
  // For Varnished pages, we could instantly call queueFlusher after all tasks
  // waiting this promise is done since in such cases, we already wait for response of
  // context/me, which is received in a later stages of JS execution compared to
  // non varnished pages.
  setTimeout(queueFlusher, constants.queueInitialFlushDelay);
}
export function initializeSenderPublishHook(hook) {
  publishHook = function () {
    hook(...arguments);
    callExternalPublishHooks(...arguments);
  };
}
export function queueEvent(event) {
  queue.push(event);
}
export function addCloseListener(listener) {
  let onlyOnce =
    arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  let hasExecuted = false;
  closeListeners.push(function () {
    if (!onlyOnce || !hasExecuted) {
      listener(...arguments);
    }
    hasExecuted = true;
  });
}
function _popEventsFromQueue() {
  const events = [...queue];
  queue.length = 0;
  _setEventSendTimes(events);
  return events;
}
async function _flush() {
  eventsInFlight = _popEventsFromQueue();
  if (!eventsInFlight.length) {
    return;
  }
  let response = null;
  try {
    response = await send(JSON.stringify(eventsInFlight));
  } catch (exception) {
    _handleFullError(exception, eventsInFlight);
  }
  if (response && response.status === 200) {
    _handleFullSuccess(eventsInFlight);
  }
  if (response && response.status === 207) {
    _handlePartialSuccess(eventsInFlight, response);
  }
  eventsInFlight.length = 0;
}
function _shouldRetryRequest(clientRetries) {
  return function (exception) {
    // Should retry on network errors(no status) and when we got a 5xx
    return (
      (!exception.request.status ||
        (exception.request.status >= 500 && exception.request.status <= 599)) &&
      clientRetries
    );
  };
}
export function _handleFullSuccess(events) {
  events.forEach((event) => {
    publishHook(event.eventData, EventStatus.SUCCESS);
  });
}
/**
 * This method warns the developer about the specific failed events in a request.
 * @param events The events sent to the server
 * @param response The response of the event collector that is used to detect the failed events
 */
function _handlePartialSuccess(events, response) {
  const failedEventsSet = new Set();
  response.data.failedEvents.forEach((responseElem) => {
    const failedEvent = events[responseElem.idx].eventData;

    // notify publish status for failures
    publishHook(failedEvent, EventStatus.FAILURE, responseElem.reason);

    // decorate response so error message shows the event
    // todo check
    responseElem.event = failedEvent;
    failedEventsSet.add(failedEvent);
  });

  // notify publish status for successes
  const successfulEvents = events.filter(
    (event) => !failedEventsSet.has(event)
  );
  successfulEvents.forEach((event) => {
    publishHook(event.eventData, EventStatus.SUCCESS);
  });
  logError(
    "Following events have failed to be persisted",
    response.data.failedEvents
  );
}
function _handleFullError(exception, events) {
  events.forEach((event) => {
    publishHook(event.eventData, EventStatus.FAILURE);
  });
  logError("Event tracking send error", exception);
}
function _handleBeaconOutcome(beaconOutcome, events) {
  const status = beaconOutcome ? EventStatus.BEACON_SENT : EventStatus.FAILURE;
  const errorMessage = beaconOutcome ? undefined : "Beacon API failed";
  events.forEach((event) => {
    publishHook(event.eventData, status, errorMessage);
  });
}
function _setEventSendTimes(events) {
  const time = Date.now();
  events.forEach((event) => {
    event.eventData.setSendTime(time);
  });
}
export const sendWithBeacon = () => {
  var _eventsInFlight;
  const events = [];

  // Send the in flight events again if the page has been unloaded during a send operation.
  // The reason we do this is because ajax requests are cancelled by the browser when the page
  // is unloaded, but beacon requests are not. So beacon requests are the only way for not
  // losing any events. This may mean duplicate events but we can de-duplicate them if needed.
  // We only fallback to beacon as a last resort because beacon API don't notify back
  // success/failures
  if (
    (_eventsInFlight = eventsInFlight) !== null &&
    _eventsInFlight !== void 0 &&
    _eventsInFlight.length
  ) {
    events.push(...eventsInFlight);
  }

  // Put the residual events on the queue that may have been added after send started
  events.push(..._popEventsFromQueue());
  if (events.length > 0) {
    const status = navigator.sendBeacon(collectorUrl, JSON.stringify(events));
    _handleBeaconOutcome(status, events);
  }
};
function triggerCloseListeners() {
  closeListeners.forEach((listener) => {
    try {
      listener();
    } catch (error) {
      captureExceptionFunc(error);
    }
  });
}
function closeSender() {
  // prevents further calls to  `queueFlusherInterval` to prevent additional events from being queued
  senderClosed = true;

  // we first trigger dependent listeners
  triggerCloseListeners();

  // then send with beacon API
  sendWithBeacon();
}
function reopenSender() {
  senderClosed = false;
}
function _setupBeacon(disablePageVisibilityTracking) {
  if (!navigator.sendBeacon) {
    return;
  }
  window.addEventListener("pagehide", closeSender);
  window.addEventListener("pageshow", (event) => {
    if (event.persisted) {
      // page restored from bfcache, resume sending events
      reopenSender();
    }
  });
  if (!disablePageVisibilityTracking) {
    document.addEventListener("visibilitychange", () => {
      tracker.publishEvent(new PageVisibilityChangeEvent(!document.hidden));
      if (document.hidden) {
        sendWithBeacon();
      }
    });
  }
}
export function _getCollectorUrl(
  appVersion,
  domainConfig,
  collectorURLOverride
) {
  const urlParams = new URLSearchParams();
  urlParams.set(constants.clientKeyUrlParam, constants.clientKey);
  urlParams.set(constants.clientVersionUrlParam, appVersion);
  const baseUrl = ((domainConfig) => {
    switch (domainConfig) {
      case DOMAIN_CONFIG.USE_DEFAULT:
        return defaultDomain + collectorPath;
      case DOMAIN_CONFIG.USE_CURRENT:
        return collectorPath;
      case DOMAIN_CONFIG.USE_PROVIDED:
        return collectorURLOverride !== null && collectorURLOverride !== void 0
          ? collectorURLOverride
          : defaultDomain + collectorPath;
    }
  })(domainConfig);
  return `${baseUrl}?${urlParams.toString()}`;
}
//# sourceMappingURL=sender.js.map
