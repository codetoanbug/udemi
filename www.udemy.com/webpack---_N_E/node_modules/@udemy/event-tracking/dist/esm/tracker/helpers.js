import { v4 as uuid } from "uuid";
/**
 * Gets the offset of the timezone. For example -4 for GMT-4
 */
export function getTimezoneOffset() {
  return (new Date().getTimezoneOffset() / 60) * -1;
}

/**
 * Decorates the function with a retry behavior.
 * The decorated function is retried if it throws an exception.
 * If shouldRetry function is not provided or if it returns false the retry can be cancelled.
 * @param fn: Function to be decorated
 * @param retryCount: How many times to retry after first try
 * @param retryGap: Gap between retries in milliseconds
 * @param shouldRetry: An optional function that decides to retry or not based on the
 * error - caller can assume the type of the error
 */
export function makeRetryingFunction(fn, retryCount) {
  let retryGap =
    arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  let shouldRetry =
    arguments.length > 3 && arguments[3] !== undefined
      ? arguments[3]
      : () => true;
  return async function () {
    for (let i = 0; i < retryCount; i++) {
      try {
        return await fn(...arguments);
      } catch (exception) {
        const lastAttempt = i + 1 === retryCount;
        const stopRetry = !shouldRetry(exception);
        if (lastAttempt || stopRetry) {
          throw exception;
        }
        retryGap && (await delay(retryGap));
      }
    }
    return fn(...arguments);
  };
}
export const delay = (ms) => {
  return new Promise((resolve) => setTimeout(resolve, ms));
};

/**
 * This is a decorator that wraps an async function with a mechanism that prevents another
 * invocation while there is an unfinished one.
 */
export function preventOverlappingCall(fn) {
  let awaiting = false;
  return async function () {
    if (awaiting) {
      return;
    }
    awaiting = true;
    const result = await fn(...arguments);
    awaiting = false;
    return result;
  };
}
let printLogs = true;

/**
 * This functions turns on the log printing on or off.
 */
export function setPrintLogs(value) {
  printLogs = value;
}
export function log() {
  if (printLogs) {
    // eslint-disable-next-line no-console
    console.log(...arguments);
  }
}
export function logError() {
  if (printLogs) {
    // eslint-disable-next-line no-console
    console.error(...arguments);
  }
}

/**
 * Use this to generate slug uuids for your objects
 * to be used for tracking
 */
export function generateTrackingId() {
  // @ts-expect-error - 'binary' option is deprecated and it doesn't live on @types/uuid
  const bytes = uuid("binary");
  return uuidToSlug(bytes);
}

/**
 * Generates short and url safe version of a UUID
 */
function uuidToSlug(uuidBytes) {
  const base64 =
    typeof window === "undefined"
      ? globalThis.Buffer.from(uuidBytes).toString()
      : btoa(uuidBytes);
  return base64.replace(/\+/g, "-").replace(/\//g, "_").substring(0, 22); // Drop '==' padding
}

/**
 * @returns {{promise: Promise; resolve: () => void; reject: () => void}}
 */
export function createDeferred() {
  const deferred = {};
  deferred.promise = new Promise((resolve, reject) => {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
}
//# sourceMappingURL=helpers.js.map
