var _dec, _class, _class2;

import {
  findFocusables,
  forceTabOrder,
  lockPageScroll,
  unlockPageScroll,
} from "@udemy/design-system-utils";
import { noop } from "@udemy/shared-utils";
import classNames from "classnames";
import { inject } from "mobx-react";
import React from "react";
import { toggleDialogForScreenReaders } from "../toggle-dialog-for-screen-readers/toggle-dialog-for-screen-readers";
export /**
 * The FocusTrappingDialog component.
 *
 * @remarks
 * This is a low level component used in the implementation of other modal components.
 * It traps the keyboard focus within the dialog, and locks the page scroll so that the
 * dialog is always in view. It does not prevent the user from using the mouse or touch input
 * to interact with elements behind the dialog; this is handled by the FullPageOverlay component.
 *
 * This component implements the w3.org best practices for handling keyboard input within modals:
 * https://www.w3.org/TR/wai-aria-practices/#dialog_modal
 * - When the dialog is opened, focus on the first focusable in the dialog.
 *   If you prefer to focus on another element, use the `findNodeToFocusOn` prop.
 * - When the dialog is opened, trap the tab order within the dialog, i.e.
 *   tab on the last focusable goes to the first focusable.
 * - When the dialog is opened, keep screen readers within the dialog, i.e.
 *   prevent them from reading the underlying page content.
 * - When the dialog is closed, return the focus to the element that opened the dialog.
 *
 * We assume that a {@link CheckedStateCheckbox} controls whether this component is shown.
 * To use this component, you must attach a ref to it and call `FocusTrappingDialog.onToggle` in
 * the `CheckedStateCheckbox`'s `onChange` handler.
 */
let FocusTrappingDialog =
  ((_dec = inject((_ref) => {
    let { focusTrappingDialogProps } = _ref;
    return {
      focusTrappingDialogProps,
    };
  })),
  _dec(
    (_class =
      ((_class2 = class FocusTrappingDialog extends React.Component {
        constructor(props) {
          var _this;

          super(props);
          _this = this;
          this.ref = void 0;
          this.scrollableContainer = void 0;
          this.disposeForceTabOrder = void 0;
          this.triggerNode = void 0;

          this.findDialogFocusable = () => {
            var _this$ref;

            return (_this$ref = this.ref) === null || _this$ref === void 0
              ? void 0
              : _this$ref.current;
          };

          this.findFirstFocusable = () => {
            return this.findElement("findFirstFocusable", 0);
          };

          this.findLastFocusable = () => {
            return this.findElement("findLastFocusable", -1);
          };

          this.findNodeToFocusOn = () => {
            return this.findElement("findNodeToFocusOn", -1);
          };

          this.onToggle = function (isOpen) {
            var _this$ref5;

            let scrollableContainer =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : null;

            if (isOpen) {
              var _this$ref2,
                _this$props$focusTrap,
                _this$ref3,
                _this$ref3$current;

              _this.scrollableContainer =
                scrollableContainer !== null && scrollableContainer !== void 0
                  ? scrollableContainer
                  : (_this$ref2 = _this.ref) === null || _this$ref2 === void 0
                  ? void 0
                  : _this$ref2.current;

              if (_this.scrollableContainer) {
                lockPageScroll(_this.scrollableContainer);
              }

              const findTriggerNode =
                (_this$props$focusTrap =
                  _this.props.focusTrappingDialogProps) === null ||
                _this$props$focusTrap === void 0
                  ? void 0
                  : _this$props$focusTrap.findTriggerNode;
              _this.triggerNode = findTriggerNode
                ? findTriggerNode()
                : document.activeElement;
              (_this$ref3 = _this.ref) === null || _this$ref3 === void 0
                ? void 0
                : (_this$ref3$current = _this$ref3.current) === null ||
                  _this$ref3$current === void 0
                ? void 0
                : _this$ref3$current.focus();
              setTimeout(() => {
                var _this$ref4;

                if (
                  (_this$ref4 = _this.ref) !== null &&
                  _this$ref4 !== void 0 &&
                  _this$ref4.current
                ) {
                  const node = _this.ref.current.querySelector(
                    "[data-dialog-auto-focus]"
                  );

                  node === null || node === void 0 ? void 0 : node.focus();
                }
              }, 0);
            } else {
              var _this$triggerNode;

              if (_this.scrollableContainer) {
                unlockPageScroll(_this.scrollableContainer);
              }

              (_this$triggerNode = _this.triggerNode) === null ||
              _this$triggerNode === void 0
                ? void 0
                : _this$triggerNode.focus();
            }

            toggleDialogForScreenReaders(
              (_this$ref5 = _this.ref) === null || _this$ref5 === void 0
                ? void 0
                : _this$ref5.current,
              isOpen
            );
          };

          this.ref = /*#__PURE__*/ React.createRef();
          this.scrollableContainer = null;
          this.disposeForceTabOrder = noop;
          this.triggerNode = null;
        }

        componentDidMount() {
          this.disposeForceTabOrder = forceTabOrder([
            [this.findDialogFocusable, this.findNodeToFocusOn],
            [this.findLastFocusable, this.findDialogFocusable],
            [this.findLastFocusable, this.findFirstFocusable],
          ]);
        }

        componentWillUnmount() {
          var _this$disposeForceTab;

          if (this.scrollableContainer) {
            unlockPageScroll(this.scrollableContainer);
          }

          this.scrollableContainer = null;
          (_this$disposeForceTab = this.disposeForceTabOrder) === null ||
          _this$disposeForceTab === void 0
            ? void 0
            : _this$disposeForceTab.call(this);
          this.triggerNode = null;
        } // eslint-disable-next-line @typescript-eslint/naming-convention

        defaultFindFocusableAtIndex(container, index) {
          const focusables = findFocusables(container);

          if (index < 0) {
            index = focusables.length + index;
          }

          return focusables[index] || null;
        }

        findElement(findFnPropKey, defaultFindIndex) {
          var _this$ref7;

          const findFn = this.props[findFnPropKey];

          if (findFn && typeof findFn === "function") {
            var _this$ref6;

            return findFn(
              (_this$ref6 = this.ref) === null || _this$ref6 === void 0
                ? void 0
                : _this$ref6.current
            );
          }

          return this.defaultFindFocusableAtIndex(
            (_this$ref7 = this.ref) === null || _this$ref7 === void 0
              ? void 0
              : _this$ref7.current,
            defaultFindIndex
          );
        }

        render() {
          const {
            children,
            findFirstFocusable,
            findLastFocusable,
            findNodeToFocusOn,
            focusTrappingDialogProps,
            labelledById,
            ...htmlProps
          } = this.props;
          return /*#__PURE__*/ React.createElement(
            "div",
            Object.assign({}, htmlProps, {
              ref: this.ref,
              role: "dialog",
              tabIndex: -1,
              "aria-labelledby": labelledById,
            }),
            children
          );
        }
      }),
      (_class2.defaultProps = {
        findFirstFocusable: undefined,
        findLastFocusable: undefined,
        findNodeToFocusOn: undefined,
        focusTrappingDialogProps: {},
      }),
      (_class2.Title = void 0),
      _class2))
  ) || _class);
/** React prop interface for the DialogTitle component. */

/**
 * The DialogTitle component
 *
 * @privateRemarks
 * Exposed to consumers via `FocusTrappingDialog.Title`
 */
const DialogTitle = (_ref2) => {
  let { children, className, show, ...props } = _ref2;
  return /*#__PURE__*/ React.createElement(
    "h2",
    Object.assign({}, props, {
      className: classNames(className, "ud-heading-lg", {
        // eslint-disable-next-line @typescript-eslint/naming-convention
        "ud-sr-only": !show,
      }),
    }),
    children
  );
};

FocusTrappingDialog.Title = DialogTitle;
//# sourceMappingURL=focus-trapping-dialog.react-component.js.map
