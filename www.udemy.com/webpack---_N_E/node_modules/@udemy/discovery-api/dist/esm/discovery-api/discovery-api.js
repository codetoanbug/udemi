import { serverOrClient, snakeCaseCopy } from "@udemy/shared-utils";
import { getConfigData, getRequestData } from "@udemy/shared-utils";
import { udApi } from "@udemy/ud-api";
import { OBJECT_ID_PARAMS, PAGE_TYPE_TO_PARAMS } from "../constants";
/**
 * This supports legacy pre-fetching of units in the monolith via Django tempaltes.
 * It should not be relied on or used in a frontends application.
 */
export const udBrowse = serverOrClient.global.UD.browse || {};
export class DiscoveryAPI {
  constructor(options, globalOverrides) {
    var _options$useCache;
    this._useCache = void 0;
    this.discoveryUnitsApiUrl = "/discovery-units/";
    this.discoveryUnitsAllCoursesApiUrl = "/discovery-units/all_courses/";
    this.globalOverrides = void 0;
    this._useCache =
      (_options$useCache =
        options === null || options === void 0 ? void 0 : options.useCache) !==
        null && _options$useCache !== void 0
        ? _options$useCache
        : false;
    this.globalOverrides = globalOverrides;
  }

  /**
   * Load courses from /discovery-units/all_courses/ API endpoint
   */
  async loadCourses(pageType) {
    let options =
      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const { params } = this._buildConfigForDiscoveryUnitsRequest(
      pageType,
      options
    );
    // _buildConfigForDiscoveryUnitsRequest ensure that params are not undefined in this context
    const paramsUnwrapped = params;
    this._addAllCoursesParams(paramsUnwrapped, pageType);
    return this._callDiscoveryUnitsAPI(
      this.discoveryUnitsAllCoursesApiUrl,
      paramsUnwrapped
    ).then((response) => {
      if ("unit" in response) {
        return response.unit;
      }
    });
  }
  async loadUnits(pageType) {
    let options =
      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const defaults = {
      from: 0,
      pageSize: 3,
      itemCount: 12,
    };
    const optionsWithDefaults = {
      ...defaults,
      ...options,
    };
    const { params, prefetchKey } = this._buildConfigForDiscoveryUnitsRequest(
      pageType,
      optionsWithDefaults
    );
    // _buildConfigForDiscoveryUnitsRequest ensure that params are not undefined in this context
    const paramsUnwrapped = params;
    return this._callDiscoveryUnitsAPI(
      this.discoveryUnitsApiUrl,
      paramsUnwrapped,
      prefetchKey
    ).then((response) => {
      const data = response.data;
      const units = data.units || [];
      return {
        has_more: units.length > 0 && !!data.more_units_available,
        last_index: data.last_unit_index,
        results: units,
      };
    });
  }
  async loadItemsForUnit(unit, pageType) {
    var _unit$url$replace, _unit$url;
    let options =
      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    this._assertValidPageType(pageType);

    // Units passed into this method should always have a URL, but AFAIK not all units are
    // necessarily returned with a URL so I left it as optional on the DiscoveryUnit type.
    const url =
      (_unit$url$replace =
        (_unit$url = unit.url) === null || _unit$url === void 0
          ? void 0
          : _unit$url.replace(/^\/api-2\.0/, "")) !== null &&
      _unit$url$replace !== void 0
        ? _unit$url$replace
        : "";
    const params = snakeCaseCopy(options);
    this._addSourcePageToParams(params, pageType);
    this._addLocaleAndCurrencyToParams(params);
    this._addExcludedCourseIdsToParams(params, options);
    this._addSkipPriceToParams(params);
    return udApi.get(url, this._getApiConfig(params)).then((response) => {
      const data = response.data;
      const {
        items,
        remaining_item_count: remainingItemCount,
        tracking_id: trackingId,
      } = data.unit;
      return {
        items,
        remaining_item_count: remainingItemCount,
        unit: response.data.unit,
        pagination: data.unit.pagination,
        tracking_id: trackingId,
        type: data.unit.type,
      };
    });
  }
  _buildConfigForDiscoveryUnitsRequest(pageType, options) {
    this._assertValidPageType(pageType);
    let context;
    if ("context" in PAGE_TYPE_TO_PARAMS[pageType]) {
      var _PAGE_TYPE_TO_PARAMS$;
      context =
        (_PAGE_TYPE_TO_PARAMS$ = PAGE_TYPE_TO_PARAMS[pageType]) === null ||
        _PAGE_TYPE_TO_PARAMS$ === void 0
          ? void 0
          : _PAGE_TYPE_TO_PARAMS$.context;
    }
    const { pageObjectId, prefetchKey, ...restOfOptions } = options;
    const params = {
      context,
      ...snakeCaseCopy(restOfOptions),
      ...(pageObjectId && {
        [OBJECT_ID_PARAMS[pageType]]: pageObjectId,
      }),
    };
    this._addSourcePageToParams(params, pageType);
    this._addLocaleAndCurrencyToParams(params);
    this._addExcludedCourseIdsToParams(params, options);
    this._addSkipPriceToParams(params);
    this._addFunnelContextToParams(params, pageType);
    return {
      params,
      prefetchKey,
    };
  }
  _callDiscoveryUnitsAPI(url, params, prefetchKey) {
    // Check for a single-use promise set by browse/__base.html
    // Note: if that file changes, this method may have to change as well
    if (
      prefetchKey &&
      udBrowse.prefetchPromises &&
      udBrowse.prefetchPromises[prefetchKey]
    ) {
      return udBrowse.prefetchPromises[prefetchKey].then((response) => {
        udBrowse.prefetchPromises[prefetchKey] = null;
        return {
          data: JSON.parse(response),
        };
      });
    }
    return udApi.get(url, this._getApiConfig(params));
  }
  _addExcludedCourseIdsToParams(params, options) {
    if (options && options.excludedCourseIds) {
      params.excluded_course_ids = options.excludedCourseIds.join(",");
    }
  }
  _addSourcePageToParams(params, pageType) {
    params.source_page = PAGE_TYPE_TO_PARAMS[pageType].source_page;
  }
  _addFunnelContextToParams(params, pageType) {
    if (
      Object.prototype.hasOwnProperty.call(
        PAGE_TYPE_TO_PARAMS[pageType],
        "funnel_context"
      )
    ) {
      params.funnel_context = PAGE_TYPE_TO_PARAMS[pageType].funnel_context;
    }
  }
  _addAllCoursesParams(params, pageType) {
    const translatedParams = PAGE_TYPE_TO_PARAMS[pageType];
    if ("sos" in translatedParams && translatedParams.sos) {
      params.sos = translatedParams.sos;
    }
    if ("fl" in translatedParams && translatedParams.fl) {
      params.fl = translatedParams.fl;
    }
    if ("context" in params) {
      delete params.context;
    }
  }
  _addLocaleAndCurrencyToParams(params) {
    var _this$globalOverrides,
      _this$globalOverrides2,
      _this$globalOverrides3,
      _this$globalOverrides4;
    const udConfig =
      (_this$globalOverrides =
        (_this$globalOverrides2 = this.globalOverrides) === null ||
        _this$globalOverrides2 === void 0
          ? void 0
          : _this$globalOverrides2.Config) !== null &&
      _this$globalOverrides !== void 0
        ? _this$globalOverrides
        : getConfigData();
    const udRequest =
      (_this$globalOverrides3 =
        (_this$globalOverrides4 = this.globalOverrides) === null ||
        _this$globalOverrides4 === void 0
          ? void 0
          : _this$globalOverrides4.request) !== null &&
      _this$globalOverrides3 !== void 0
        ? _this$globalOverrides3
        : getRequestData();
    if (udRequest.locale) {
      params.locale = udRequest.locale;
    }
    if (udConfig.price_country && udConfig.price_country.currency) {
      params.currency = udConfig.price_country.currency;
    }
    if (udRequest.navigation_locale) {
      params.navigation_locale = udRequest.navigation_locale;
    }
  }
  _getApiConfig(params) {
    return {
      params,
      useCache: this._useCache,
    };
  }
  _assertValidPageType(pageType) {
    if (PAGE_TYPE_TO_PARAMS[pageType] === undefined) {
      throw new TypeError(`Invalid page type "${pageType}"`);
    }
  }
  _addSkipPriceToParams(params) {
    params.skip_price = true;
  }
}
//# sourceMappingURL=discovery-api.js.map
