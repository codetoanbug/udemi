var _class;

/* eslint-disable @typescript-eslint/naming-convention */
import {
  getUniqueId,
  findFocusables,
  FocusCycle,
} from "@udemy/design-system-utils";
import { useMatchMedia, withMatchMedia } from "@udemy/hooks";
import { useI18n } from "@udemy/i18n";
import ExpandIcon from "@udemy/icons/dist/expand.ud-icon";
import { Button, BlockList } from "@udemy/react-core-components";
import { BottomDrawer } from "@udemy/react-dialog-components";
import { Popper } from "@udemy/react-popup-components";
import { autopilot, noop } from "@udemy/shared-utils";
import { pxToRem } from "@udemy/styles";
import classNames from "classnames";
import { Provider } from "mobx-react";
import React from "react";
import styles from "./dropdown.module.css";
const DropdownContext = /*#__PURE__*/ React.createContext({
  onToggle: noop,
});
/** React component props for the DropdownButton component. */

/** The Dropdown triggering button */
const DropdownButton = (_ref) => {
  let { children, withIcon = true, udStyle = "secondary", ...props } = _ref;
  return /*#__PURE__*/ React.createElement(
    Button,
    Object.assign(
      {
        udStyle: udStyle,
      },
      props
    ),
    children,
    withIcon &&
      /*#__PURE__*/ React.createElement(ExpandIcon, {
        label: false,
      })
  );
};
/**
 * Internal component that side-steps refactoring Dropdown to
 * use higher order component for i18n functions.
 */

const BottomDrawerTitle = () => {
  const { gettext } = useI18n();
  return /*#__PURE__*/ React.createElement(
    React.Fragment,
    null,
    gettext("Menu")
  );
};

DropdownButton.displayName = "DropdownButton";
/** `BlockList` props with an optional `size` */

/** The content of a Dropdown when opened. */
const DropdownMenu = (_ref2) => {
  let { size = "small", ...props } = _ref2;
  const isMobileSized = useMatchMedia("mobile-max");
  return /*#__PURE__*/ React.createElement(
    BlockList,
    Object.assign({}, props, {
      size: isMobileSized ? "large" : size,
    })
  );
};

DropdownMenu.displayName = "DropdownMenu";
/**
 * Dropdown Menu Item, an implementation of BlockListItem
 *
 * @privateRemarks
 * - We assume this will be using the defaults of `componentClass='button'` and `loading=false`.
 * - We are omitting `to` and `componentClass` as it helps TSC with the discrimination union.
 *   Otherwise it complains that `to` is required.
 */
// Converting DropdownMenuItem breaks unit tests because IntersectionObserver is used in `<LearningFilter/>
// it's attempting to pass on a ref, but that ref moves onto BlockList.Item, which is not set up for React.forwardRef
// Retaining this work for later to return
// const DropdownMenuItem = React.forwardRef<
//     HTMLButtonElement | HTMLAnchorElement,
//     Omit<BlockListItemProps, 'to' | 'componentClass' | 'loading'>
// >((props, ref) => {
//     const {$$udDropdown} = React.useContext(MobXProviderContext);
//     const onClick = (event: React.MouseEvent<HTMLButtonElement>) => {
//         const result = props.onClick?.(event);
//         /** @ts-expect-error void | undefined and booleans are not comparable in TypeScript */
//         result !== false && $$udDropdown.props.onToggle(false);
//     };
//     return <BlockList.Item ref={ref} {...props} onClick={onClick} />;
// });
// DropdownMenuItem.displayName = 'DropdownMenuItem';

class DropdownMenuItem extends React.Component {
  constructor() {
    super(...arguments);

    this.onClick = (event) => {
      var _this$props$onClick, _this$props;

      const result =
        (_this$props$onClick = (_this$props = this.props).onClick) === null ||
        _this$props$onClick === void 0
          ? void 0
          : _this$props$onClick.call(_this$props, event);

      if (typeof result === "undefined" || result !== false) {
        this.context.onToggle(false);
      }
    };
  }

  render() {
    return /*#__PURE__*/ React.createElement(
      BlockList.Item,
      Object.assign({}, this.props, {
        onClick: this.onClick,
      })
    );
  }
}
/** Object for containing the various sizes of a Dropdown Menu object. */

DropdownMenuItem.defaultProps = {
  componentClass: "button",
};
DropdownMenuItem.contextType = DropdownContext;
export const menuWidths = {
  auto: "auto",
  fullWidth: "100%",
  xsmall: `${pxToRem(120)}rem`,
  small: `${pxToRem(160)}rem`,
  medium: `${pxToRem(200)}rem`,
  large: `${pxToRem(260)}rem`,
};
/** React props interface for Dropdown component */

/**
 * The Dropdown Component, wrapped in autopilot
 * @internal
 *
 * @remarks
 * The actual returned `Dropdown` component is an `Object.assign` to apply
 * values and skirt TypeScript typing for values that do not exist on the DropdownBase component
 * ex: Dropdown.MenuItem
 */
const DropdownWithAutopilot = autopilot(
  "isOpen",
  "onToggle"
)(
  ((_class = class extends React.Component {
    constructor(_props) {
      var _this;

      super(_props);
      _this = this;
      this.hasOpened = void 0;
      this.triggerId = void 0;
      this.drawerId = void 0;
      this.focusTrappingDialogProps = void 0;
      this.dropdownContentRef = void 0;

      this.onOpenDrawer = () => {
        var _this$props$onToggle, _this$props2;

        (_this$props$onToggle = (_this$props2 = this.props).onToggle) ===
          null || _this$props$onToggle === void 0
          ? void 0
          : _this$props$onToggle.call(_this$props2, true);
        !this.hasOpened && this.props.onFirstOpen && this.props.onFirstOpen();
        this.hasOpened = true;
      };

      this.onCloseDrawer = () => {
        var _this$props$onToggle2, _this$props3;

        (_this$props$onToggle2 = (_this$props3 = this.props).onToggle) ===
          null || _this$props$onToggle2 === void 0
          ? void 0
          : _this$props$onToggle2.call(_this$props3, false);
      };

      this.renderContent = function (props) {
        var _this$props$menuWidth, _this$props$renderCon, _this$props4;

        const width =
          menuWidths[
            (_this$props$menuWidth = _this.props.menuWidth) !== null &&
            _this$props$menuWidth !== void 0
              ? _this$props$menuWidth
              : "medium"
          ];
        const style = { ...props.style, width };

        for (
          var _len = arguments.length,
            args = new Array(_len > 1 ? _len - 1 : 0),
            _key = 1;
          _key < _len;
          _key++
        ) {
          args[_key - 1] = arguments[_key];
        }

        return (_this$props$renderCon = (_this$props4 = _this.props)
          .renderContent) === null || _this$props$renderCon === void 0
          ? void 0
          : _this$props$renderCon.call(
              _this$props4,
              { ...props, style },
              ...args
            );
      };

      this.getPopperFocusables = () => {
        var _this$dropdownContent;

        return [
          // Dropddown trigger
          document.getElementById(this.triggerId), // Menu items
          ...findFocusables(
            (_this$dropdownContent = this.dropdownContentRef) === null ||
              _this$dropdownContent === void 0
              ? void 0
              : _this$dropdownContent.current
          ),
        ];
      };

      this.triggerId =
        this.props.trigger.props.id || getUniqueId("dropdown-trigger");
      this.drawerId = getUniqueId("dropdown-drawer");
      this.hasOpened = false;
      this.dropdownContentRef = /*#__PURE__*/ React.createRef(); // If a dropdown menu item opens a modal on click, we want the focus to return to
      // the dropdown trigger when the modal closes. The default behavior returns focus to
      // the thing that opened the modal, which doesn't work because the dropdown menu closes
      // when a menu item is clicked.

      this.focusTrappingDialogProps = {
        findTriggerNode: () => document.getElementById(this.triggerId),
      };
    }

    render() {
      const {
        children,
        forwardedRef,
        menuMaxHeight,
        menuWidth,
        useDrawer = this.props.isMobileMax && !this.props.isFinePointer,
        isMobileMax,
        isFinePointer,
        ...props
      } = this.props;
      const dropdownContext = {
        onToggle: this.props.onToggle,
      };
      const detachedContent = props.detachFromTarget
        ? this.dropdownContentRef
        : undefined;

      if (useDrawer) {
        return /*#__PURE__*/ React.createElement(
          Provider,
          {
            focusTrappingDialogProps: this.focusTrappingDialogProps,
          },
          /*#__PURE__*/ React.createElement(
            DropdownContext.Provider,
            {
              value: dropdownContext,
            },
            /*#__PURE__*/ React.createElement(
              "div",
              {
                className: "note",
              },
              /*#__PURE__*/ React.cloneElement(props.trigger, {
                id: this.triggerId,
                cssToggleId: this.drawerId,
              })
            ),
            /*#__PURE__*/ React.createElement(
              BottomDrawer,
              {
                ref: forwardedRef,
                id: this.drawerId,
                title: /*#__PURE__*/ React.createElement(
                  BottomDrawerTitle,
                  null
                ),
                showTitle: false,
                isOpen: props.isOpen,
                onOpen: this.onOpenDrawer,
                onClose: this.onCloseDrawer,
                className: styles["bottom-drawer"],
              },
              /*#__PURE__*/ React.createElement(
                "div",
                {
                  className: styles.menu,
                },
                children
              )
            )
          )
        );
      }

      return /*#__PURE__*/ React.createElement(
        Provider,
        {
          focusTrappingDialogProps: this.focusTrappingDialogProps,
        },
        /*#__PURE__*/ React.createElement(
          DropdownContext.Provider,
          {
            value: dropdownContext,
          },
          /*#__PURE__*/ React.createElement(
            FocusCycle,
            {
              getCycle: this.getPopperFocusables,
              detachedContent: detachedContent,
            },
            /*#__PURE__*/ React.createElement(
              Popper,
              Object.assign(
                {
                  ref: forwardedRef,
                },
                props,
                {
                  trigger: /*#__PURE__*/ React.cloneElement(props.trigger, {
                    id: this.triggerId,
                  }),
                  renderContent: this.renderContent,
                }
              ),
              /*#__PURE__*/ React.createElement(
                "div",
                {
                  className: classNames(styles.menu, styles["dropdown-menu"]),
                  style: {
                    maxHeight: menuMaxHeight,
                  },
                  ref: this.dropdownContentRef,
                },
                children
              )
            )
          )
        )
      );
    }
  }),
  (_class.defaultProps = {
    ...Popper.defaultProps,
    isOpen: false,
    menuMaxHeight: `${pxToRem(280)}rem`,
    menuWidth: "medium",
    useDrawer: undefined,
    componentClass: "div",
  }),
  _class)
);
const DropdownWithMatchMedia = withMatchMedia({
  isMobileMax: "mobile-max",
  isFinePointer: "(pointer: fine), not (any-pointer: coarse)",
})(DropdownWithAutopilot);
/**
 * ### The Dropdown Component.
 * @see {@link makeDropdown}
 */

export const Dropdown = Object.assign(
  /*#__PURE__*/ React.forwardRef((props, ref) =>
    /*#__PURE__*/ React.createElement(
      DropdownWithMatchMedia,
      Object.assign({}, props, {
        forwardedRef: ref,
      })
    )
  ),
  {
    defaultProps: DropdownWithAutopilot.defaultProps,
    Button: DropdownButton,
    Menu: DropdownMenu,
    MenuItem: DropdownMenuItem,
    displayName: "Dropdown",
  }
);
//# sourceMappingURL=dropdown.react-component.js.map
