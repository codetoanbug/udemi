import _initializerDefineProperty from "@babel/runtime/helpers/initializerDefineProperty";
import _initializerWarningHelper from "@babel/runtime/helpers/initializerWarningHelper";
import _applyDecoratedDescriptor from "@babel/runtime/helpers/applyDecoratedDescriptor";

var _class,
  _class2,
  _descriptor,
  _descriptor2,
  _descriptor3,
  _descriptor4,
  _descriptor5,
  _class3;

import { action, observable } from "mobx";
import { observer } from "mobx-react";
import React from "react";
import { Carousel } from "./carousel.react-component";
/** Event dispatched when the `AutoplayCarousel` has a change to it's autoplay interval */

export /**
 * The AutoPlayCarousel component.
 *
 * @remarks
 * This component currently only works on carousels that show one item at a time.
 * To make auto play possible, we insert the last item of the carousel in the front of the carousel
 * and the first item of the carousel in the end of the carousel to make an infinite scroll.
 * Then, we update the scroll port position to the real first or last item.
 */
let AutoPlayCarousel =
  observer(
    (_class =
      ((_class2 =
        ((_class3 = class AutoPlayCarousel extends React.Component {
          constructor() {
            super(...arguments);

            _initializerDefineProperty(this, "canAutoPlay", _descriptor, this);

            _initializerDefineProperty(
              this,
              "allowAutoPlay",
              _descriptor2,
              this
            );

            _initializerDefineProperty(this, "isPaused", _descriptor3, this);

            this.autoPlayInterval = void 0;
            this.ref = /*#__PURE__*/ React.createRef();

            _initializerDefineProperty(
              this,
              "handleCarouselMutation",
              _descriptor4,
              this
            );

            _initializerDefineProperty(
              this,
              "handleIntervalUpdate",
              _descriptor5,
              this
            );

            this.advanceCarousel = () => {
              if (this.ref.current) {
                const scrollPort = this.ref.current.scrollPortRef.current;
                scrollPort === null || scrollPort === void 0
                  ? void 0
                  : scrollPort.scrollBy({
                      left: scrollPort.clientWidth,
                      behavior: "smooth",
                    });
              }
            };

            this.resumeCarousel = () => {
              if (!this.autoPlayInterval && this.allowAutoPlay) {
                this.isPaused = false;
                this.autoPlayInterval = setInterval(
                  this.advanceCarousel,
                  this.props.intervalDuration
                );
                this.handleIntervalUpdate();
              }
            };

            this.pauseCarousel = () => {
              clearInterval(this.autoPlayInterval);
              this.isPaused = true;
              this.autoPlayInterval = 0;
              this.handleIntervalUpdate();
            };

            this.onInteraction = () => {
              if (this.allowAutoPlay) {
                this.allowAutoPlay = false;
                this.pauseCarousel();
              }
            };
          }

          componentDidMount() {
            const hasMoreThanOneChild =
              React.Children.count(this.props.children) > 1;

            if (hasMoreThanOneChild) {
              // AutoPlayCarousel only works on carousels that show one item at a time.
              // Assume the item takes up the entire width of the carousel and
              // compare the width of an item to the carousel width.
              if (this.ref.current) {
                const scrollPort = this.ref.current.scrollPortRef.current;
                const firstChild =
                  scrollPort === null || scrollPort === void 0
                    ? void 0
                    : scrollPort.firstChild;
                const carouselItemWidth = firstChild.clientWidth;
                const roundedCarouselItemWidth =
                  Math.ceil(carouselItemWidth / 5) * 5;
                const carouselWidth =
                  scrollPort === null || scrollPort === void 0
                    ? void 0
                    : scrollPort.clientWidth;

                if (carouselWidth) {
                  const roundedCarouselWidth = Math.ceil(carouselWidth / 5) * 5;

                  if (
                    carouselWidth > 0 &&
                    roundedCarouselItemWidth === roundedCarouselWidth
                  ) {
                    this.canAutoPlay = true;
                    this.isPaused = false;
                    scrollPort.scrollLeft = carouselItemWidth;
                    this.resumeCarousel();
                  }
                }
              }
            }
          }

          componentWillUnmount() {
            this.pauseCarousel();
          }

          get items() {
            const children = React.Children.toArray(this.props.children);

            if (this.canAutoPlay) {
              // Append the first item to the end, and prepend the last item to the front,
              // so the last item auto plays to the first, and the first item scrolls to last item
              // when the previous button is clicked if auto play is active.
              const lastItem = children[children.length - 1];
              const firstItem = children[0];
              children.unshift(lastItem);
              children.push(firstItem);
            }

            return children;
          }

          pageCount(scrollPort) {
            const extraWidth = scrollPort.clientWidth * 2;
            return Math.floor(
              (scrollPort.scrollWidth - extraWidth) / scrollPort.clientWidth
            );
          }

          visiblePageIndex(scrollPort) {
            return Math.floor(
              (scrollPort.scrollLeft - scrollPort.clientWidth) /
                scrollPort.clientWidth
            );
          }

          render() {
            const {
              prioritizeTouch,
              allowScroll,
              onIntervalUpdate,
              intervalDuration,
              ...props
            } = this.props;
            const allowScrolling =
              allowScroll == true ? allowScroll : prioritizeTouch;
            const autoPlayControls = prioritizeTouch
              ? {
                  onTouchStart: this.canAutoPlay
                    ? this.onInteraction
                    : undefined,
                  onTouchEnd: this.canAutoPlay
                    ? this.resumeCarousel
                    : undefined,
                }
              : {
                  onMouseEnter: this.canAutoPlay
                    ? this.pauseCarousel
                    : undefined,
                  onMouseLeave: this.canAutoPlay
                    ? this.resumeCarousel
                    : undefined,
                  onMouseDown: this.canAutoPlay
                    ? this.onInteraction
                    : undefined,
                };
            return /*#__PURE__*/ React.createElement(
              "div",
              autoPlayControls,
              /*#__PURE__*/ React.createElement(
                Carousel,
                Object.assign({}, props, {
                  showPager:
                    this.props.showPager &&
                    React.Children.count(this.props.children) > 1,
                  allowScroll: allowScrolling,
                  isInfiniteScroll: true,
                  pageByFullWidth: true,
                  gridFullWidthItems: true,
                  onMutation: this.handleCarouselMutation,
                  ref: this.ref,
                }),
                this.items
              )
            );
          }
        }),
        (_class3.defaultProps = {
          ...Carousel.defaultProps,
          showPager: null,
          prioritizeTouch: false,
          intervalDuration: 7000,
        }),
        _class3)),
      (_applyDecoratedDescriptor(
        _class2.prototype,
        "componentDidMount",
        [action],
        Object.getOwnPropertyDescriptor(_class2.prototype, "componentDidMount"),
        _class2.prototype
      ),
      (_descriptor = _applyDecoratedDescriptor(
        _class2.prototype,
        "canAutoPlay",
        [observable],
        {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function () {
            return false;
          },
        }
      )),
      (_descriptor2 = _applyDecoratedDescriptor(
        _class2.prototype,
        "allowAutoPlay",
        [observable],
        {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function () {
            return true;
          },
        }
      )),
      (_descriptor3 = _applyDecoratedDescriptor(
        _class2.prototype,
        "isPaused",
        [observable],
        {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function () {
            return true;
          },
        }
      )),
      (_descriptor4 = _applyDecoratedDescriptor(
        _class2.prototype,
        "handleCarouselMutation",
        [action],
        {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function () {
            return (event) => {
              if (this.canAutoPlay && this.ref.current) {
                const carousel = this.ref.current;
                const scrollPort = carousel.scrollPortRef.current; // Update the scroll port position to the real first or last item.

                if (scrollPort) {
                  var _this$props$onMutatio, _this$props;

                  if (carousel.isLastPage) {
                    scrollPort.scrollLeft = scrollPort.clientWidth;
                  } else if (carousel.isFirstPage) {
                    scrollPort.scrollLeft =
                      scrollPort.clientWidth * (this.items.length - 2);
                  }

                  const mutationEvent = {
                    isLastPage: event.isLastPage,
                    isPageable: event.isPageable,
                    pageCount: this.pageCount(scrollPort),
                    visiblePageIndex: this.visiblePageIndex(scrollPort),
                  };
                  (_this$props$onMutatio = (_this$props = this.props)
                    .onMutation) === null || _this$props$onMutatio === void 0
                    ? void 0
                    : _this$props$onMutatio.call(_this$props, mutationEvent);
                }
              }
            };
          },
        }
      )),
      (_descriptor5 = _applyDecoratedDescriptor(
        _class2.prototype,
        "handleIntervalUpdate",
        [action],
        {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function () {
            return () => {
              var _this$props$onInterva, _this$props2;

              const event = {
                isPaused: this.isPaused,
                intervalDuration: this.props.intervalDuration,
              };
              (_this$props$onInterva = (_this$props2 = this.props)
                .onIntervalUpdate) === null || _this$props$onInterva === void 0
                ? void 0
                : _this$props$onInterva.call(_this$props2, event);
            };
          },
        }
      ))),
      _class2))
  ) || _class;
//# sourceMappingURL=auto-play-carousel.react-component.js.map
