import _initializerDefineProperty from "@babel/runtime/helpers/initializerDefineProperty";
import _initializerWarningHelper from "@babel/runtime/helpers/initializerWarningHelper";
import _applyDecoratedDescriptor from "@babel/runtime/helpers/applyDecoratedDescriptor";

var _class,
  _class2,
  _descriptor,
  _descriptor2,
  _descriptor3,
  _descriptor4,
  _class3;

import { findFocusables, getUniqueId } from "@udemy/design-system-utils";
import { useI18n } from "@udemy/i18n";
import NextIcon from "@udemy/icons/dist/next.ud-icon";
import PreviousIcon from "@udemy/icons/dist/previous.ud-icon";
import { IconButton } from "@udemy/react-core-components";
import { Loader } from "@udemy/react-reveal-components";
import { debounce, noop } from "@udemy/shared-utils";
import classNames from "classnames";
import { action, computed, observable, reaction } from "mobx";
import { observer } from "mobx-react";
import React from "react";
import UAParser from "ua-parser-js";
import styles from "./carousel.module.css";
/** Number of milliseconds to debounce the {@link Carousel} scrollHandler */

export const CAROUSEL_ON_SCROLL_DEBOUNCE_INTERVAL = 100;
/**
 * Icon for button to navigate to next set of children.
 *
 * @remarks
 * Separated as a functional component to use i18n hook.
 */

const CarouselNextIcon = () => {
  const { gettext } = useI18n();
  return /*#__PURE__*/ React.createElement(NextIcon, {
    size: "large",
    color: "inherit",
    label: gettext("Next"),
  });
};
/**
 * Icon for button to navigate to previous set of children.
 *
 * @remarks
 * Separated as a functional component to use i18n hook.
 */

const CarouselPreviousIcon = () => {
  const { gettext } = useI18n();
  return /*#__PURE__*/ React.createElement(PreviousIcon, {
    size: "large",
    color: "inherit",
    label: gettext("Previous"),
  });
};
/** Event dispatched when the carousel mounts, when the children nodes change, or when the user scrolls the carousel. */

/**
 * HTML `section` wrapper used to infer region role to Carousel.
 *
 */
const CarouselRegion = (_ref) => {
  let { ariaLabel, children } = _ref;
  const { gettext } = useI18n();
  return /*#__PURE__*/ React.createElement(
    "section",
    {
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      "aria-label": ariaLabel || gettext("Carousel"),
      className: styles.container,
    },
    children
  );
};
/** The React props interface for the Carousel component. */

export /**
 * The Carousel component.
 *
 * @remarks
 * This component supports both scrolling and pagination.
 * To ensure the best pagination experience, rather than rendering a list of items, render a list of pages.
 * Each page should contain logic to responsively render its own items.
 *
 * If you must render a list of items, in order for pagination to work reliably,
 * i.e., not inadvertently skip items, make sure that the scrollport width is a multiple of the scroll item width, including margins.
 *
 * ex. scrollport width = 500px; scrollitem width = 250px (including borders, margins)
 *
 * This is because we rely on scrollsnap CSS property to align the scroll items after the paging (element.scrollBy) operation,
 * which simply scrolls the scrollport element in the horizontal direction by its own clientWidth.
 *
 * Since scroll snap picks the closest element to snap to the edge,
 * it can potentially skip an element when it lies in the "grey area" between the pages.
 */
let Carousel =
  observer(
    (_class =
      ((_class2 =
        ((_class3 = class Carousel extends React.Component {
          constructor(props) {
            var _this$props$id;

            super(props);
            this.destroy = void 0;
            this.lastChild = void 0;
            this.scrollPortRef = void 0;
            this.scrollBehavior = void 0;
            this.shouldFocusOnFirstVisibleItem = void 0;
            this.id = void 0;

            _initializerDefineProperty(this, "scroll", _descriptor, this);

            _initializerDefineProperty(this, "isLoading", _descriptor2, this);

            _initializerDefineProperty(
              this,
              "setIsLoading",
              _descriptor3,
              this
            );

            this.handleLastChildEnter = async (isLastPage) => {
              if (!isLastPage) {
                return;
              }

              const { children, onLoadMore } = this.props;
              const lastChild = children[React.Children.count(children) - 1];

              if (this.lastChild !== lastChild) {
                this.lastChild = lastChild;
                await (onLoadMore === null || onLoadMore === void 0
                  ? void 0
                  : onLoadMore());
              }
            };

            this.handleClick = async (event) => {
              const { clientWidth, scrollWidth, scrollLeft } =
                this.scrollPortRef.current;
              const scrollAmount = this.props.pageByFullWidth
                ? clientWidth
                : 0.8 * clientWidth;

              if (event.currentTarget.dataset.pagerType === "next") {
                var _this$props$onNextCli, _this$props, _this$scrollPortRef$c;

                (_this$props$onNextCli = (_this$props = this.props)
                  .onNextClick) === null || _this$props$onNextCli === void 0
                  ? void 0
                  : _this$props$onNextCli.call(_this$props);

                if (this.props.onLoadMore) {
                  const scrollAmountRemaining =
                    scrollWidth - (scrollLeft + clientWidth);

                  if (scrollAmountRemaining < scrollAmount) {
                    this.setIsLoading(true);
                    await this.props.onLoadMore();
                  }
                }

                this.setIsLoading(false);
                (_this$scrollPortRef$c = this.scrollPortRef.current) === null ||
                _this$scrollPortRef$c === void 0
                  ? void 0
                  : _this$scrollPortRef$c.scrollBy({
                      left: scrollAmount,
                      behavior: this.scrollBehavior,
                    });
              } else {
                var _this$props$onPreviou, _this$props2, _this$scrollPortRef$c2;

                (_this$props$onPreviou = (_this$props2 = this.props)
                  .onPreviousClick) === null || _this$props$onPreviou === void 0
                  ? void 0
                  : _this$props$onPreviou.call(_this$props2);
                (_this$scrollPortRef$c2 = this.scrollPortRef.current) ===
                  null || _this$scrollPortRef$c2 === void 0
                  ? void 0
                  : _this$scrollPortRef$c2.scrollBy({
                      left: -scrollAmount,
                      behavior: this.scrollBehavior,
                    });
              }

              this.shouldFocusOnFirstVisibleItem = true;
            };

            _initializerDefineProperty(
              this,
              "handleCarouselMutation",
              _descriptor4,
              this
            );

            this.scrollHandler = debounce(
              this.handleCarouselMutation,
              CAROUSEL_ON_SCROLL_DEBOUNCE_INTERVAL
            );
            this.scrollPortRef = /*#__PURE__*/ React.createRef();
            this.id =
              (_this$props$id = this.props.id) !== null &&
              _this$props$id !== void 0
                ? _this$props$id
                : getUniqueId("scroll-port");
            this.destroy = noop;
            this.shouldFocusOnFirstVisibleItem = false;
            /**
             * TODO: Remove once Safari fixes smooth scrolling issue
             * See https://bugs.webkit.org/show_bug.cgi?id=238497
             * and https://bugs.webkit.org/show_bug.cgi?id=242224
             * 2022-09-13: fix committed, but unclear if released with Safari 16:
             *    https://webkit.org/blog/13152/webkit-features-in-safari-16-0/
             */

            const uaParser = new UAParser();
            this.scrollBehavior =
              uaParser.getBrowser().name === "Safari" ? "auto" : "smooth";
          }

          componentDidMount() {
            if (this.props.onLoadMore) {
              this.destroy = reaction(
                () => this.isLastPage,
                this.handleLastChildEnter
              );
            }

            this.handleCarouselMutation();
          }

          componentDidUpdate(prevProps) {
            if (prevProps.children !== this.props.children) {
              this.handleCarouselMutation();
            }
          }

          componentWillUnmount() {
            this.destroy();
          }

          get isFirstPage() {
            return this.scroll.x === 0;
          }

          get isLastPage() {
            const { x, clientWidth, totalWidth } = this.scroll; // Round to nearest 5, there can be a small offset due to hidden items / borders

            return this.round(x + clientWidth) === this.round(totalWidth);
          }

          get isPageable() {
            // Usage of nullish coalescing vs OR operator introduces a bug where pager buttons do not appear.
            // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
            return this.props.isInfiniteScroll || this.pageCount > 1;
          }

          get pageCount() {
            if (this.props.isInfiniteScroll) {
              return null;
            }

            return Math.ceil(this.scroll.totalWidth / this.scroll.clientWidth);
          }

          get visiblePageIndex() {
            if (this.props.isInfiniteScroll) {
              return null;
            }

            return Math.ceil(this.scroll.x / this.scroll.clientWidth);
          }

          round(n) {
            let precision =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : 5;
            return Math.round(n / precision) * precision;
          }

          focusOnFirstVisibleItem() {
            var _this$scrollPortRef$c3, _this$scrollPortRef$c4;

            const left =
              (_this$scrollPortRef$c3 = this.scrollPortRef.current) === null ||
              _this$scrollPortRef$c3 === void 0
                ? void 0
                : _this$scrollPortRef$c3.getBoundingClientRect().left;

            if (
              (_this$scrollPortRef$c4 = this.scrollPortRef.current) !== null &&
              _this$scrollPortRef$c4 !== void 0 &&
              _this$scrollPortRef$c4.childNodes &&
              left
            ) {
              var _this$scrollPortRef$c5;

              const items = Array.from(
                (_this$scrollPortRef$c5 = this.scrollPortRef.current) ===
                  null || _this$scrollPortRef$c5 === void 0
                  ? void 0
                  : _this$scrollPortRef$c5.childNodes
              );
              const firstVisibleItem = items.find(
                (item) => item.getBoundingClientRect().left >= left
              );
              const focusable =
                firstVisibleItem && findFocusables(firstVisibleItem)[0];
              focusable === null || focusable === void 0
                ? void 0
                : focusable.focus();
            }
          }

          render() {
            const {
              allowScroll,
              children,
              id,
              onLoadMore,
              onMutation,
              pagerButtonClassName,
              pagerButtonSize,
              className,
              itemClassName,
              smallGrid,
              gridSize,
              showPager,
              isInfiniteScroll,
              gridMode,
              gridFullWidthItems,
              pageByFullWidth,
              ariaLive,
              ariaLabel,
              onNextClick,
              onPreviousClick,
              fullViewport,
              ...props
            } = this.props;
            const nextIcon = this.isLoading
              ? /*#__PURE__*/ React.createElement(Loader, {
                  color: "inherit",
                })
              : /*#__PURE__*/ React.createElement(CarouselNextIcon, null);
            const pager = /*#__PURE__*/ React.createElement(
              React.Fragment,
              null,
              /*#__PURE__*/ React.createElement(
                IconButton,
                {
                  className: classNames(
                    "ud-carousel-pager-button",
                    "ud-carousel-pager-button-prev",
                    pagerButtonClassName,
                    styles.button,
                    styles["prev-button"]
                  ),
                  size: pagerButtonSize,
                  udStyle: "primary",
                  round: true,
                  onClick: this.handleClick,
                  "data-pager-type": "prev",
                  disabled: isInfiniteScroll ? false : this.isFirstPage,
                },
                /*#__PURE__*/ React.createElement(CarouselPreviousIcon, null)
              ),
              /*#__PURE__*/ React.createElement(
                IconButton,
                {
                  className: classNames(
                    "ud-carousel-pager-button",
                    "ud-carousel-pager-button-next",
                    pagerButtonClassName,
                    styles.button,
                    styles["next-button"]
                  ),
                  size: pagerButtonSize,
                  udStyle: "primary",
                  round: true,
                  onClick: this.handleClick,
                  "data-pager-type": "next",
                  disabled: isInfiniteScroll ? false : this.isLastPage,
                },
                nextIcon
              )
            );
            return /*#__PURE__*/ React.createElement(
              CarouselRegion,
              {
                ariaLabel: ariaLabel,
              },
              /*#__PURE__*/ React.createElement(
                "div",
                Object.assign(
                  {
                    ref: this.scrollPortRef,
                    className: classNames(className, styles["scroll-port"], {
                      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
                      [styles["small-grid"]]: smallGrid || gridSize === "small",
                      [styles["large-grid"]]: gridSize === "large",
                      [styles.grid]: gridMode,
                      [styles["grid-full-width-items"]]:
                        gridMode && gridFullWidthItems,
                      [styles["scroll-lock"]]: !allowScroll,
                      // eslint-disable-next-line @typescript-eslint/naming-convention
                      "ud-full-viewport-container": fullViewport,
                      [styles["container-full-viewport"]]: fullViewport,
                    }),
                    "data-purpose": "scroll-port",
                  },
                  props,
                  {
                    id: this.id,
                    onScroll: this.scrollHandler,
                    "aria-live": ariaLive,
                  }
                ),
                React.Children.map(children, (child, i) =>
                  /*#__PURE__*/ React.createElement(
                    "div",
                    {
                      "data-index": i,
                      className: classNames(
                        itemClassName,
                        styles["scroll-item"]
                      ),
                      key: i,
                    },
                    child
                  )
                )
              ),
              this.isPageable && showPager && pager
            );
          }
        }),
        (_class3.defaultProps = {
          allowScroll: false,
          pagerButtonClassName: undefined,
          pagerButtonSize: "large",
          className: undefined,
          itemClassName: undefined,
          id: undefined,
          onLoadMore: undefined,
          onMutation: undefined,
          smallGrid: false,
          gridSize: "medium",
          showPager: true,
          isInfiniteScroll: false,
          gridMode: true,
          gridFullWidthItems: false,
          pageByFullWidth: false,
          ariaLive: "polite",
          ariaLabel: undefined,
          onNextClick: noop,
          onPreviousClick: noop,
          fullViewport: false,
        }),
        _class3)),
      (_applyDecoratedDescriptor(
        _class2.prototype,
        "componentDidMount",
        [action],
        Object.getOwnPropertyDescriptor(_class2.prototype, "componentDidMount"),
        _class2.prototype
      ),
      (_descriptor = _applyDecoratedDescriptor(
        _class2.prototype,
        "scroll",
        [observable],
        {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function () {
            return {
              x: 0,
              clientWidth: 0,
              totalWidth: 0,
            };
          },
        }
      )),
      (_descriptor2 = _applyDecoratedDescriptor(
        _class2.prototype,
        "isLoading",
        [observable],
        {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function () {
            return false;
          },
        }
      )),
      (_descriptor3 = _applyDecoratedDescriptor(
        _class2.prototype,
        "setIsLoading",
        [action],
        {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function () {
            return (isLoading) => {
              this.isLoading = isLoading;
            };
          },
        }
      )),
      _applyDecoratedDescriptor(
        _class2.prototype,
        "isFirstPage",
        [computed],
        Object.getOwnPropertyDescriptor(_class2.prototype, "isFirstPage"),
        _class2.prototype
      ),
      _applyDecoratedDescriptor(
        _class2.prototype,
        "isLastPage",
        [computed],
        Object.getOwnPropertyDescriptor(_class2.prototype, "isLastPage"),
        _class2.prototype
      ),
      _applyDecoratedDescriptor(
        _class2.prototype,
        "isPageable",
        [computed],
        Object.getOwnPropertyDescriptor(_class2.prototype, "isPageable"),
        _class2.prototype
      ),
      _applyDecoratedDescriptor(
        _class2.prototype,
        "pageCount",
        [computed],
        Object.getOwnPropertyDescriptor(_class2.prototype, "pageCount"),
        _class2.prototype
      ),
      _applyDecoratedDescriptor(
        _class2.prototype,
        "visiblePageIndex",
        [computed],
        Object.getOwnPropertyDescriptor(_class2.prototype, "visiblePageIndex"),
        _class2.prototype
      ),
      (_descriptor4 = _applyDecoratedDescriptor(
        _class2.prototype,
        "handleCarouselMutation",
        [action],
        {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function () {
            return () => {
              if (this.scrollPortRef.current) {
                var _this$props$onMutatio, _this$props3;

                const { clientWidth, scrollWidth, scrollLeft } =
                  this.scrollPortRef.current;
                this.scroll = {
                  x: scrollLeft,
                  totalWidth: scrollWidth,
                  clientWidth,
                };

                if (this.shouldFocusOnFirstVisibleItem) {
                  this.focusOnFirstVisibleItem();
                  this.shouldFocusOnFirstVisibleItem = false;
                }

                (_this$props$onMutatio = (_this$props3 = this.props)
                  .onMutation) === null || _this$props$onMutatio === void 0
                  ? void 0
                  : _this$props$onMutatio.call(_this$props3, {
                      isLastPage: this.isLastPage,
                      isPageable: this.isPageable,
                      pageCount: this.pageCount,
                      visiblePageIndex: this.visiblePageIndex,
                    });
              }
            };
          },
        }
      ))),
      _class2))
  ) || _class;
//# sourceMappingURL=carousel.react-component.js.map
