import _initializerDefineProperty from "@babel/runtime/helpers/initializerDefineProperty";
import _applyDecoratedDescriptor from "@babel/runtime/helpers/applyDecoratedDescriptor";
import _initializerWarningHelper from "@babel/runtime/helpers/initializerWarningHelper";

var _class, _class2, _descriptor, _descriptor2, _descriptor3, _class3;

import _includesInstanceProperty from "core-js-pure/stable/instance/includes.js";

/* eslint-disable @typescript-eslint/naming-convention */
import {
  getUniqueId,
  RootCloseWrapper,
  ROOT_CLOSE_REASON,
} from "@udemy/design-system-utils";
import { useMatchMedia } from "@udemy/hooks";
import { CheckedStateCheckbox } from "@udemy/react-checked-state-components";
import { noop } from "@udemy/shared-utils";
import classNames from "classnames";
import { action, observable } from "mobx";
import { observer } from "mobx-react";
import PropTypes from "prop-types";
import React, { createContext } from "react";
import styles from "./popper.module.css";
/**
 * @remarks
 * Maps popover placement to `position: absolute` styles needed to render the placement.
 * The order of the keys matters; see `getPlacementsInPreferredOrder` in {@link Popper}.
 */

export const POPPER_PLACEMENT = {
  "top-start": {
    bottom: "100%",
    left: "0",
  },
  "top-end": {
    bottom: "100%",
    right: "0",
  },
  top: {
    bottom: "100%",
    left: "50%",
    transform: "translateX(-50%)",
  },
  "right-start": {
    left: "100%",
    top: "0",
  },
  "right-end": {
    left: "100%",
    bottom: "0",
  },
  right: {
    left: "100%",
    top: "50%",
    transform: "translateY(-50%)",
  },
  "bottom-start": {
    top: "100%",
    left: "0",
  },
  "bottom-end": {
    top: "100%",
    right: "0",
  },
  bottom: {
    top: "100%",
    left: "50%",
    transform: "translateX(-50%)",
  },
  "left-start": {
    right: "100%",
    top: "0",
  },
  "left-end": {
    right: "100%",
    bottom: "0",
  },
  left: {
    right: "100%",
    top: "50%",
    transform: "translateY(-50%)",
  },
};
/** The potential placements of a BasicPopper. */

let currentlyOpenPopper = null;
/** The four major cardinal directions that placement of a Popper can occur. */

/**
 * @remarks
 * Given a placement key, returns the cardinal part of that key
 *
 * @param placement a {@link BasicPopperPlacementKey} key
 * @returns the cardinal part of the key, ex: 'top'
 */
export function getMajorPlacement(placement) {
  return placement.split("-")[0];
}
/**
 * @param placement a {@link BasicPopperPlacementKey} key
 * @returns boolean true if placement is `top` or `bottom`
 */

export function isVertical(placement) {
  var _context;

  return _includesInstanceProperty((_context = ["top", "bottom"])).call(
    _context,
    getMajorPlacement(placement)
  );
}

/** React Context for a Popper Modal */
export const PopperModalContext = /*#__PURE__*/ createContext({
  /**
   * Modal dialog components in tree below this component should
   * call onMount after they have been mounted to the tree.
   */
  onMount: noop,

  /**
   * Call onUnmount after they have been removed from the tree
   * and this popper can close.
   */
  onUnmount: noop,
});
/** The React props interface for the RenderContent function */

/** The Default renderContent prop used to render BasicPopper content. */
export function defaultRenderContent(props) {
  const { children, ...wrapperProps } = props;
  return /*#__PURE__*/ React.createElement(
    "div",
    wrapperProps,
    /*#__PURE__*/ React.createElement(
      "div",
      {
        className: styles["animation-wrapper"],
      },
      children
    )
  );
}
export const basicPopperPropTypes = {
  children: PropTypes.node.isRequired,
  className: PropTypes.string,

  /** The placement of the BasicPopper when it opens. */
  placement: PropTypes.oneOf(Object.keys(POPPER_PLACEMENT)).isRequired,

  /** The Trigger element used ot open the BasicPopper */
  trigger: PropTypes.element.isRequired,
  getTriggerRect: PropTypes.func,

  /**
   * Flag to control the open state of the `BasicPopper`
   *
   * @remarks
   * Include `isOpen` if you want to use` BasicPopper` as a controlled component. Changes
   * to `isOpen` are signaled by `onToggle` events. If `isOpen` is omitted from props,
   * `BasicPopper` will keep track of its open/close state internally, as an uncontrolled
   * component.
   */
  isOpen: PropTypes.bool,

  /**
   * Flag to toggle the BasicPopper on hover
   *
   * @defaultValue `false` in `BasicPopper`
   */
  canToggleOnHover: PropTypes.bool,

  /**
   * The `role` attribute to apply to the `BasicPopper`.
   *
   * @defaultValue `popup` in `BasicPopper`
   */
  a11yRole: PropTypes.oneOf(["popup", "description", "none"]),

  /**
   * Flag to determine if opening oen `BasicPopper` should close other open ones.
   *
   * @defaultValue `true` in `BasicPopper`
   */
  shouldCloseOtherPoppers: PropTypes.bool,

  /**
   * Optional event handler for when the `BasicPopper` is toggled.
   *
   * @remarks
   * `onToggle` is dispatched when the open/close state changes. Listen to this event
   * if you are controlling `BasicPopper` state through the isOpen prop.
   */
  onToggle: PropTypes.func,

  /** Optional handler to fire when the `BasicPopper` first opens. */
  onFirstOpen: PropTypes.func,

  /** Provided by {@link menuAim} function. */
  onMenuAimUpdate: PropTypes.func,

  /**
   * The type of element to use when rendering the `BasicPopper`
   *
   * @defaultValue `div` in `BasicPopper`
   */
  componentClass: PropTypes.elementType,

  /** Optional The render content function to use when rendering the `BasicPopper` */
  renderContent: PropTypes.func,

  /**
   * Toggle strategy for `BasicPopper`.
   *
   * - `show-hide`: always render children, even if the popper is closed
   * - `add-remove`: only render children if the popper is open; do not
   *   render (or remove them) if closed
   *
   * @defaultValue `show-hide` in `BasicPopper`
   */
  toggleStrategy: PropTypes.oneOf(["show-hide", "add-remove"]),

  /**
   * Flag to determine whether or not the `BasicPopper` can only be toggled by hovering (and not focusing).
   * Note that you still need to implement a way to toggle on focus; otherwise, the `BasicPopper` will not
   * work on mobile devices or for keyboard users.
   */
  canOnlyToggleOnHover: PropTypes.bool,
};
/** React props interface for `PopperTrigger`  */

/**
 *
 * ### BasicPopper Trigger
 * @returns
 */
const BasicPopperTrigger = observer((_ref) => {
  let {
    trigger,
    triggerId,
    isOpen,
    contentId,
    isPopupRole,
    isDescriptionRole,
    canToggleOnHover,
    onTriggerClick,
  } = _ref;
  const triggerProps = {
    id: triggerId,
  };

  if (isPopupRole) {
    triggerProps["aria-expanded"] = isOpen;
  } else if (isDescriptionRole) {
    triggerProps["aria-describedby"] = contentId;
  }

  if (!canToggleOnHover) {
    triggerProps.onClick = onTriggerClick;
  }

  if (trigger.props.tabIndex === undefined) {
    triggerProps.tabIndex = 0;
  }

  return /*#__PURE__*/ React.cloneElement(
    React.Children.only(trigger),
    triggerProps
  );
});

/**
 * Renders popper trigger, content (children), and sets up events that
 * initiate the popper trigger.
 *
 * @internal
 * @privateRemarks
 *
 * This component is distinct from `BasicPopper` because the latter is
 * difficult to refactor out of a class component. As long as hover/trigger
 * logic depends on references to external hooks, it is simpler to maintain
 * this as a separate component than to refactor `BasicPopper` with a higher-
 * order component wrapper.
 */
const BasicPopperInternal = observer((_ref2) => {
  let {
    triggerId,
    contentId,
    isOpen,
    isPopupRole,
    isDescriptionRole,
    onTriggerClick,
    onMouseEnter,
    onMouseLeave,
    onBlurClose,
    handleFocus,
    children,
    ...props
  } = _ref2;
  const PopperComponent = props.componentClass; // If the primary pointing device does not support hovering, then disable
  // toggle on hover behavior; fall back to requiring a click.

  const canPrimaryHover = !!useMatchMedia("(hover: hover)");
  const canToggleOnHoverCheck = props.canToggleOnHover && canPrimaryHover;
  return /*#__PURE__*/ React.createElement(
    PopperComponent,
    {
      className: classNames(styles.popper, props.className, {
        "ud-popper-open": isOpen,
      }),
      onMouseEnter: canToggleOnHoverCheck ? onMouseEnter : undefined,
      onMouseLeave: canToggleOnHoverCheck ? onMouseLeave : undefined,
      onFocus:
        !props.canOnlyToggleOnHover && canToggleOnHoverCheck
          ? handleFocus
          : undefined,
      onBlur: canToggleOnHoverCheck ? onBlurClose : undefined,
    },
    props.trigger.props.cssToggleId &&
      /*#__PURE__*/ React.createElement(CheckedStateCheckbox, {
        id: props.trigger.props.cssToggleId,
        checked: isOpen,
        onChange: props.onToggle,
        className: styles["popper-checkbox"],
      }),
    /*#__PURE__*/ React.createElement(BasicPopperTrigger, {
      triggerId: triggerId,
      trigger: props.trigger,
      isPopupRole: isPopupRole,
      isDescriptionRole: isDescriptionRole,
      contentId: contentId,
      isOpen: isOpen,
      canToggleOnHover: canToggleOnHoverCheck,
      onTriggerClick: onTriggerClick,
    }),
    children
  );
});
/**
 * The `BasicPopper` component.
 */

export let BasicPopper =
  observer(
    (_class =
      ((_class2 =
        ((_class3 = class BasicPopper extends React.Component {
          constructor(props) {
            var _this;

            super(props);
            _this = this;
            this.triggerId = void 0;
            this.contentId = void 0;
            this.triggerNode = null;
            this.contentNode = null;
            this.focusNode = null;
            this.hasOpened = false;
            this.isModalInPopper = false;
            this.popperModalContext = void 0;

            _initializerDefineProperty(
              this,
              "contentOffset",
              _descriptor,
              this
            );

            this.isControlledComponent = () =>
              typeof this.props.isOpen !== "undefined";

            _initializerDefineProperty(
              this,
              "isOpenShadowValue",
              _descriptor2,
              this
            );

            _initializerDefineProperty(
              this,
              "handleToggle",
              _descriptor3,
              this
            );

            this.onToggle = () => {
              this.isOpen ? this.onClose() : this.onOpen();
            };

            this.onTriggerClick = function () {
              _this.onToggle();

              if (typeof _this.props.trigger.props.onClick === "function") {
                _this.props.trigger.props.onClick(...arguments);
              }
            };

            this.onOpen = () => {
              if (!this.isOpen) {
                if (this.props.shouldCloseOtherPoppers) {
                  if (currentlyOpenPopper) {
                    currentlyOpenPopper.onClose();
                  } // eslint-disable-next-line @typescript-eslint/no-this-alias

                  currentlyOpenPopper = this;
                }

                this.handleToggle(true);
                !this.hasOpened &&
                  this.props.onFirstOpen &&
                  this.props.onFirstOpen();
                this.hasOpened = true;
              }
            };

            this.onClose = () => {
              if (this.isOpen) {
                if (currentlyOpenPopper === this) {
                  currentlyOpenPopper = null;
                }

                this.handleToggle(false);
              }
            };

            this.onRootClose = (event, container, reason) => {
              if (
                reason === ROOT_CLOSE_REASON.KEYBOARD &&
                container !== null &&
                container !== void 0 &&
                container.contains(event.target)
              ) {
                var _this$triggerNode;

                if (this.isOpen) {
                  event.stopPropagation();
                }

                (_this$triggerNode = this.triggerNode) === null ||
                _this$triggerNode === void 0
                  ? void 0
                  : _this$triggerNode.focus();
              }

              this.onClose();
            };

            this.onFocusOpen = (focusNode) => {
              var _this$focusNode;

              this.focusNode =
                (_this$focusNode = this.focusNode) !== null &&
                _this$focusNode !== void 0
                  ? _this$focusNode
                  : focusNode;
              this.onOpen();
            };

            this.handleFocus = (event) => {
              this.onFocusOpen(event.currentTarget);
            };

            this.onBlurClose = () => {
              setTimeout(() => {
                var _this$focusNode2, _this$contentNode;

                if (
                  this.focusNode &&
                  !this.isModalInPopper &&
                  !(
                    (_this$focusNode2 = this.focusNode) !== null &&
                    _this$focusNode2 !== void 0 &&
                    _this$focusNode2.contains(document.activeElement)
                  ) &&
                  !(
                    (_this$contentNode = this.contentNode) !== null &&
                    _this$contentNode !== void 0 &&
                    _this$contentNode.contains(document.activeElement)
                  ) &&
                  !this.isInsideDetachedPopperContent(document.activeElement)
                ) {
                  this.onClose();
                }

                this.focusNode = null;
              }, 0);
            };

            this.onMouseEnter = () => {
              if (!this.isModalInPopper) {
                this.onOpen();

                if (this.props.onMenuAimUpdate) {
                  setTimeout(this.props.onMenuAimUpdate, 0); // Wait for menu to render.
                }
              }
            };

            this.onMouseLeave = () => {
              if (!this.isModalInPopper) {
                this.onClose();
              }
            };

            this.handleChildModalMount = () => {
              this.isModalInPopper = true; // Recursively call up to any parent BasicPoppers

              this.context.onMount();
            };

            this.handleChildModalUnmount = () => {
              if (this.isModalInPopper) {
                this.onClose();
              }

              this.isModalInPopper = false; // Recursively call up to any parent BasicPoppers

              this.context.onUnmount();
            };

            this.triggerId =
              this.props.trigger.props.id || getUniqueId("popper-trigger");
            this.contentId = getUniqueId("popper-content");
            this.popperModalContext = {
              onMount: this.handleChildModalMount,
              onUnmount: this.handleChildModalUnmount,
            };
          }

          componentDidMount() {
            this.triggerNode = document.getElementById(this.triggerId);
            this.contentNode = document.getElementById(this.contentId);
            this.updateContentOffset();
          }

          componentDidUpdate() {
            this.updateContentOffset();
          }

          componentWillUnmount() {
            if (currentlyOpenPopper === this) {
              currentlyOpenPopper = null;
            }

            this.focusNode = this.triggerNode = this.contentNode = null;
          } // These properties are current accessed by outside components

          // Check to determine if popper is visible/open.
          get isOpen() {
            return this.isControlledComponent()
              ? this.props.isOpen
              : this.isOpenShadowValue;
          }

          updateContentOffset() {
            if (!this.isOpen || !this.triggerNode || !this.contentNode) {
              this.contentOffset = null;
            } else if (this.props.getTriggerRect) {
              // Problems with this line in tests? Try using `attachTo` when you mount the component
              // so that the elements will be available in the document.
              const triggerRect = this.props.getTriggerRect(this.triggerNode);
              const contentRect = this.contentNode.getBoundingClientRect();

              if (isVertical(this.props.placement)) {
                this.contentOffset =
                  triggerRect.left - contentRect.left + triggerRect.width / 2;
              } else {
                this.contentOffset =
                  triggerRect.top - contentRect.top + triggerRect.height / 2;
              }
            }
          }

          isInsideDetachedPopperContent(node) {
            var _this$contentNode2;

            const contentNodes = Array.from(
              document.querySelectorAll("body > .ud-popper-open")
            );
            const contentNode = contentNodes.find((contentNode) =>
              contentNode.contains(node)
            );
            const triggerId =
              contentNode === null || contentNode === void 0
                ? void 0
                : contentNode.getAttribute("aria-labelledby");
            const triggerNode = triggerId && document.getElementById(triggerId);
            return (
              !!triggerNode &&
              ((_this$contentNode2 = this.contentNode) === null ||
              _this$contentNode2 === void 0
                ? void 0
                : _this$contentNode2.contains(triggerNode))
            );
          }

          render() {
            const {
              isOpen,
              onToggle,
              placement,
              renderContent,
              ...internalProps
            } = this.props;
            const isPopupRole = this.props.a11yRole === "popup";
            const isDescriptionRole = this.props.a11yRole === "description";
            const contentProps = {
              id: this.contentId,
              "aria-labelledby": isPopupRole ? this.triggerId : undefined,
              className: classNames(styles["popper-content"], {
                "ud-popper-open": this.isOpen,
              }),
              style: POPPER_PLACEMENT[placement],
              children:
                (this.props.toggleStrategy === "show-hide" || this.isOpen) &&
                this.props.children,
            };
            return /*#__PURE__*/ React.createElement(
              PopperModalContext.Provider,
              {
                value: this.popperModalContext,
              },
              /*#__PURE__*/ React.createElement(
                RootCloseWrapper,
                {
                  onRootClose: this.onRootClose,
                },
                this.props.componentClass &&
                  /*#__PURE__*/ React.createElement(
                    BasicPopperInternal,
                    Object.assign(
                      {
                        isOpen: this.isOpen,
                        triggerId: this.triggerId,
                        contentId: this.contentId,
                        isPopupRole: isPopupRole,
                        isDescriptionRole: isDescriptionRole,
                        onTriggerClick: this.onTriggerClick,
                        onMouseEnter: this.onMouseEnter,
                        onMouseLeave: this.onMouseLeave,
                        onToggle: this.onToggle,
                        onBlurClose: this.onBlurClose,
                        handleFocus: this.handleFocus,
                      },
                      internalProps
                    ),
                    renderContent === null || renderContent === void 0
                      ? void 0
                      : renderContent(
                          contentProps,
                          placement,
                          this.contentOffset
                        )
                  )
              )
            );
          }
        }),
        (_class3.defaultProps = {
          getTriggerRect: (triggerNode) => triggerNode.getBoundingClientRect(),
          canToggleOnHover: false,
          a11yRole: "popup",
          shouldCloseOtherPoppers: true,
          onFirstOpen: undefined,
          onMenuAimUpdate: undefined,
          onToggle: noop,
          componentClass: "div",
          renderContent: defaultRenderContent,
          toggleStrategy: "show-hide",
          canOnlyToggleOnHover: false,
        }),
        _class3)),
      ((_descriptor = _applyDecoratedDescriptor(
        _class2.prototype,
        "contentOffset",
        [observable],
        {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function () {
            return null;
          },
        }
      )),
      (_descriptor2 = _applyDecoratedDescriptor(
        _class2.prototype,
        "isOpenShadowValue",
        [observable],
        {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function () {
            return false;
          },
        }
      )),
      (_descriptor3 = _applyDecoratedDescriptor(
        _class2.prototype,
        "handleToggle",
        [action],
        {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function () {
            return (isOpen) => {
              var _this$props$onToggle, _this$props;

              // If component is controlled, then maintain open state with internal property.
              if (!this.isControlledComponent()) {
                this.isOpenShadowValue = isOpen;
              } // Regardless of whether open state is maintained internally or externally,
              // communicate state via toggle event.

              (_this$props$onToggle = (_this$props = this.props).onToggle) ===
                null || _this$props$onToggle === void 0
                ? void 0
                : _this$props$onToggle.call(_this$props, isOpen);
            };
          },
        }
      )),
      _applyDecoratedDescriptor(
        _class2.prototype,
        "updateContentOffset",
        [action],
        Object.getOwnPropertyDescriptor(
          _class2.prototype,
          "updateContentOffset"
        ),
        _class2.prototype
      )),
      _class2))
  ) || _class;
BasicPopper.contextType = PopperModalContext;
//# sourceMappingURL=basic-popper.react-component.js.map
