import _initializerDefineProperty from "@babel/runtime/helpers/initializerDefineProperty";
import _applyDecoratedDescriptor from "@babel/runtime/helpers/applyDecoratedDescriptor";
import _initializerWarningHelper from "@babel/runtime/helpers/initializerWarningHelper";

var _dec,
  _dec2,
  _class,
  _class2,
  _descriptor,
  _descriptor2,
  _descriptor3,
  _descriptor4,
  _class3;

import {
  Keys,
  findFocusables,
  forceTabOrder,
  ROOT_CLOSE_REASON,
  RootCloseWrapperContext,
} from "@udemy/design-system-utils";
import { debounce, noop, serverOrClient } from "@udemy/shared-utils";
import { action, observable } from "mobx";
import { observer } from "mobx-react";
import PropTypes from "prop-types";
import React from "react";
import ReactDOM from "react-dom";
import {
  BasicPopper,
  basicPopperPropTypes,
  POPPER_PLACEMENT,
} from "../basic-popper/basic-popper.react-component";
const OPPOSITE_SIDE = {
  top: "bottom",
  left: "right",
  right: "left",
  bottom: "top",
};
/**
 * Debounce length (to change placement, if necessary) in milliseconds.
 *
 * @remarks
 * Most phones re-render at most 60 frames per second,  so there are at least 1/60s or 16.7ms between frames.
 *
 * @see https://support.unity3d.com/hc/en-us/articles/205824295-Mobile-game-flips-between-running-at-30FPS-and-60FPS
 */

export const DEBOUNCE_MILLIS = 16;
export /**
 * The Popper component.
 *
 * @remarks
 * Avoid direct usage of this component. It exists to abstract common
 * behaviors for displaying overlays, and shouldn't be used directly in applications.
 *
 * This component adds the following behavior to BasicPopper:
 * - Auto-positioning: when the window is resized, the popper content remains within the document.
 * - getScrollContainers: (see PopperProps)
 * - detachFromTarget: (see PopperProps)
 */
let Popper =
  ((_dec = observable.ref),
  (_dec2 = observable.ref),
  observer(
    (_class =
      ((_class2 =
        ((_class3 = class Popper extends React.Component {
          constructor(_props) {
            var _this;

            super(_props);
            _this = this;
            this.ref = void 0;
            this.triggerNode = void 0;
            this.contentNode = void 0;
            this.debouncedUpdatePlacement = void 0;
            this.disposeForceTabOrder = noop;
            this.isScrollListenerSetUp = void 0;
            this.POPPER_PLACEMENT = POPPER_PLACEMENT;

            _initializerDefineProperty(
              this,
              "forcedPlacement",
              _descriptor,
              this
            );

            _initializerDefineProperty(this, "position", _descriptor2, this);

            _initializerDefineProperty(
              this,
              "detachedFromTargetPosition",
              _descriptor3,
              this
            );

            _initializerDefineProperty(
              this,
              "updatePlacement",
              _descriptor4,
              this
            );

            this.onToggle = (isOpen) => {
              var _this$props$onToggle, _this$props;

              (_this$props$onToggle = (_this$props = this.props).onToggle) ===
                null || _this$props$onToggle === void 0
                ? void 0
                : _this$props$onToggle.call(_this$props, isOpen);

              if (isOpen && this.contentNode) {
                // The popper content is about to show. We need to wait for it to show
                // so that we can accurately measure the width of the content, hence the setTimeout.
                // But we don't want the user to see the content flicker in case we change the
                // placement, so set `opacity: 0` until we've figured out the placement.
                this.contentNode.style.opacity = (0).toString();
                setTimeout(() => {
                  this.updatePlacement();

                  if (this.contentNode) {
                    // Remove override.
                    this.contentNode.style.opacity = "";
                  }
                }, 0);
              }
            };

            this.onEscape = (event, container) => {
              var _this$ref$current;

              (_this$ref$current = this.ref.current) === null ||
              _this$ref$current === void 0
                ? void 0
                : _this$ref$current.onRootClose(
                    event,
                    container,
                    ROOT_CLOSE_REASON.KEYBOARD
                  );
            };

            this.renderContent = function (props) {
              var _this$position,
                _this$forcedPlacement,
                _this$props$renderCon2,
                _this$props3;

              // This will override the default positioning styles provided by the BasicPopper.
              let style =
                (_this$position = _this.position) !== null &&
                _this$position !== void 0
                  ? _this$position
                  : POPPER_PLACEMENT[
                      (_this$forcedPlacement = _this.forcedPlacement) !==
                        null && _this$forcedPlacement !== void 0
                        ? _this$forcedPlacement
                        : _this.props.placement
                    ];

              for (
                var _len = arguments.length,
                  args = new Array(_len > 1 ? _len - 1 : 0),
                  _key = 1;
                _key < _len;
                _key++
              ) {
                args[_key - 1] = arguments[_key];
              }

              if (_this.props.detachFromTarget) {
                var _this$props$renderCon, _this$props2;

                style = _this.detachedFromTargetPosition;
                return /*#__PURE__*/ ReactDOM.createPortal(
                  /*#__PURE__*/ React.createElement(
                    DetachedPopperContent,
                    {
                      onEscape: _this.onEscape,
                    },
                    (_this$props$renderCon = (_this$props2 = _this.props)
                      .renderContent) === null ||
                      _this$props$renderCon === void 0
                      ? void 0
                      : _this$props$renderCon.call(
                          _this$props2,
                          { ...props, style },
                          ...args
                        )
                  ),
                  document.body
                );
              }

              return (_this$props$renderCon2 = (_this$props3 = _this.props)
                .renderContent) === null || _this$props$renderCon2 === void 0
                ? void 0
                : _this$props$renderCon2.call(
                    _this$props3,
                    { ...props, style },
                    ...args
                  );
            };

            this.ref = /*#__PURE__*/ React.createRef();
            this.debouncedUpdatePlacement = debounce(
              this.updatePlacement,
              DEBOUNCE_MILLIS
            );
          }

          componentDidMount() {
            var _this$ref$current2, _this$ref$current3;

            this.triggerNode =
              (_this$ref$current2 = this.ref.current) === null ||
              _this$ref$current2 === void 0
                ? void 0
                : _this$ref$current2.triggerNode;
            this.contentNode =
              (_this$ref$current3 = this.ref.current) === null ||
              _this$ref$current3 === void 0
                ? void 0
                : _this$ref$current3.contentNode;
            serverOrClient.global.addEventListener(
              "resize",
              this.debouncedUpdatePlacement,
              {
                passive: true,
              }
            );
            this.updatePlacement();

            if (this.props.detachFromTarget) {
              const findTriggerNode = () => {
                var _this$ref$current4;

                if (
                  (_this$ref$current4 = this.ref.current) !== null &&
                  _this$ref$current4 !== void 0 &&
                  _this$ref$current4.isOpen
                ) {
                  return this.triggerNode;
                }
              };

              const findFirstFocusableInContent = () => {
                var _this$ref$current5;

                if (
                  (_this$ref$current5 = this.ref.current) !== null &&
                  _this$ref$current5 !== void 0 &&
                  _this$ref$current5.isOpen &&
                  this.contentNode
                ) {
                  return findFocusables(this.contentNode)[0];
                }
              };

              const findLastFocusableInContent = () => {
                var _this$ref$current6;

                if (
                  (_this$ref$current6 = this.ref.current) !== null &&
                  _this$ref$current6 !== void 0 &&
                  _this$ref$current6.isOpen &&
                  this.contentNode
                ) {
                  const focusables = findFocusables(this.contentNode);
                  return focusables[focusables.length - 1];
                }
              };

              if (this.props.getTabOrder) {
                this.disposeForceTabOrder = forceTabOrder(
                  this.props.getTabOrder({
                    findTriggerNode,
                    findFirstFocusableInContent,
                    findLastFocusableInContent,
                  })
                );
              }
            }
          }

          componentDidUpdate(prevProps) {
            !prevProps.isOpen && this.props.isOpen && this.updatePlacement();
          }

          componentWillUnmount() {
            var _this$props$getScroll, _this$props$getScroll2, _this$props4;

            serverOrClient.global.removeEventListener(
              "resize",
              this.debouncedUpdatePlacement
            );
            const scrollContainers =
              (_this$props$getScroll =
                (_this$props$getScroll2 = (_this$props4 = this.props)
                  .getScrollContainers) === null ||
                _this$props$getScroll2 === void 0
                  ? void 0
                  : _this$props$getScroll2
                      .call(_this$props4)
                      .filter(Boolean)) !== null &&
              _this$props$getScroll !== void 0
                ? _this$props$getScroll
                : [];

            if (this.isScrollListenerSetUp) {
              scrollContainers.forEach((scrollContainer) => {
                scrollContainer.removeEventListener(
                  "scroll",
                  this.updatePlacement
                );
              });
            }

            this.disposeForceTabOrder();
            this.triggerNode = this.contentNode = null;
          }

          getPlacementsInPreferredOrder() {
            // Preferred order:
            // 1. The given placement.
            // 2. Placements on the same side as the given placement.
            // 3. The placement on the opposite side, with the same alignment.
            // 4. The rest of the placements on the opposite side.
            // 5. The rest of the placements.
            const [preferredSide, preferredAlignment] =
              this.props.placement.split("-");
            const oppositeSide = OPPOSITE_SIDE[preferredSide];
            const withSameSide = [];
            const withOppositeSide = [];
            const theRest = [];
            Object.keys(POPPER_PLACEMENT).forEach((placement) => {
              const [side, alignment] = placement.split("-");
              const insertMethod =
                alignment === preferredAlignment ? "unshift" : "push";

              if (side === preferredSide) {
                withSameSide[insertMethod](placement);
              } else if (side === oppositeSide) {
                withOppositeSide[insertMethod](placement);
              } else {
                theRest[insertMethod](placement);
              }
            });
            return withSameSide.concat(withOppositeSide).concat(theRest);
          }

          getContentFit(contentRect, containerRect) {
            // `fits` is whether the content fits entirely in the container.
            // `area` is how much of the content fits in the container.
            const { top: t, left: l, width: w, height: h } = contentRect;
            const r = l + w; // right

            const b = t + h; // bottom

            const { top: ct, right: cr, bottom: cb, left: cl } = containerRect;
            const fits = t >= ct && l >= cl && r <= cr && b <= cb;
            const area =
              (Math.min(r, cr) - Math.max(l, cl)) *
              (Math.min(b, cb) - Math.max(t, ct));
            return {
              fits,
              area,
            };
          }

          getContentRect(placement, triggerRect, contentRect) {
            // For the given placement, return where the content would be.
            const { top: tt, right: tr, bottom: tb, left: tl } = triggerRect;
            const tw = tr - tl; // Trigger width

            const th = tb - tt; // Trigger height

            const w = contentRect.right - contentRect.left; // Content width

            const h = contentRect.bottom - contentRect.top; // Content height

            switch (placement) {
              case "top-start":
                return {
                  top: tt - h,
                  left: tl,
                  width: w,
                  height: h,
                };

              case "top":
                return {
                  top: tt - h,
                  left: tl + tw / 2 - w / 2,
                  width: w,
                  height: h,
                };

              case "top-end":
                return {
                  top: tt - h,
                  left: tr - w,
                  width: w,
                  height: h,
                };

              case "right-start":
                return {
                  top: tt,
                  left: tr,
                  width: w,
                  height: h,
                };

              case "right":
                return {
                  top: tt + th / 2 - h / 2,
                  left: tr,
                  width: w,
                  height: h,
                };

              case "right-end":
                return {
                  top: tb - h,
                  left: tr,
                  width: w,
                  height: h,
                };

              case "bottom-start":
                return {
                  top: tb,
                  left: tl,
                  width: w,
                  height: h,
                };

              case "bottom":
                return {
                  top: tb,
                  left: tl + tw / 2 - w / 2,
                  width: w,
                  height: h,
                };

              case "bottom-end":
                return {
                  top: tb,
                  left: tr - w,
                  width: w,
                  height: h,
                };

              case "left-start":
                return {
                  top: tt,
                  left: tl - w,
                  width: w,
                  height: h,
                };

              case "left":
                return {
                  top: tt + th / 2 - h / 2,
                  left: tl - w,
                  width: w,
                  height: h,
                };

              case "left-end":
                return {
                  top: tb - h,
                  left: tl - w,
                  width: w,
                  height: h,
                };
            }
          }

          render() {
            var _this$forcedPlacement2;

            const { detachFromTarget, ...props } = this.props;
            return /*#__PURE__*/ React.createElement(
              BasicPopper,
              Object.assign({}, props, {
                onToggle: this.onToggle,
                placement:
                  (_this$forcedPlacement2 = this.forcedPlacement) !== null &&
                  _this$forcedPlacement2 !== void 0
                    ? _this$forcedPlacement2
                    : props.placement,
                renderContent: this.renderContent,
                ref: this.ref,
              })
            );
          }
        }),
        (_class3.propTypes = {
          ...basicPopperPropTypes,
          detachFromTarget: PropTypes.bool,
          getTabOrder: PropTypes.func,
          getScrollContainers: PropTypes.func,
        }),
        (_class3.defaultProps = {
          ...BasicPopper.defaultProps,
          detachFromTarget: false,
          getTabOrder: (selectors) => {
            return [
              [
                selectors.findTriggerNode,
                selectors.findFirstFocusableInContent,
              ],
              [selectors.findLastFocusableInContent, selectors.findTriggerNode],
            ];
          },
          getScrollContainers: () => [],
        }),
        _class3)),
      ((_descriptor = _applyDecoratedDescriptor(
        _class2.prototype,
        "forcedPlacement",
        [observable],
        {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function () {
            return null;
          },
        }
      )),
      (_descriptor2 = _applyDecoratedDescriptor(
        _class2.prototype,
        "position",
        [_dec],
        {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function () {
            return null;
          },
        }
      )),
      (_descriptor3 = _applyDecoratedDescriptor(
        _class2.prototype,
        "detachedFromTargetPosition",
        [_dec2],
        {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function () {
            return undefined;
          },
        }
      )),
      (_descriptor4 = _applyDecoratedDescriptor(
        _class2.prototype,
        "updatePlacement",
        [action],
        {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function () {
            return () => {
              var _ref, _forced;

              if (!this.triggerNode || !this.contentNode || !this.ref.current) {
                // The component unmounted. Don't do anything.
                return;
              }

              if (!this.ref.current.isOpen) {
                // The content isn't shown. Don't do anything.
                return;
              }

              if (!this.props.getTriggerRect) {
                // Need getTriggerRect to proceed
                return;
              }

              const triggerRect = this.props.getTriggerRect(this.triggerNode);
              const contentRect = this.contentNode.getBoundingClientRect();
              const containerRect = document.body.getBoundingClientRect(); // Look for a placement that fits.
              // If none of them fit, go with 'top-start' or 'bottom-start' (whichever has more room),
              // and adjust `left` to fit as much content as possible.

              let forced, fallback, first;

              for (const placement of this.getPlacementsInPreferredOrder()) {
                var _first;

                const rect = this.getContentRect(
                  placement,
                  triggerRect,
                  contentRect
                );
                const { fits, area } = this.getContentFit(rect, containerRect);

                if (fits) {
                  forced = {
                    placement,
                    rect,
                    leftOffset: 0,
                  };
                  break;
                }

                if (placement === "top-start" || placement === "bottom-start") {
                  if (!fallback || area > fallback.area) {
                    fallback = {
                      placement,
                      rect,
                      area,
                      leftOffset: 0,
                    };
                    const overflow =
                      rect.left + rect.width - containerRect.right;

                    if (overflow > 0) {
                      fallback.leftOffset = -Math.min(
                        rect.left - containerRect.left,
                        overflow
                      );
                    }
                  }
                }

                first =
                  (_first = first) !== null && _first !== void 0
                    ? _first
                    : {
                        placement,
                        rect,
                        leftOffset: 0,
                      };
              } // Assert: final will be assigned

              const final =
                (_ref =
                  (_forced = forced) !== null && _forced !== void 0
                    ? _forced
                    : fallback) !== null && _ref !== void 0
                  ? _ref
                  : first;

              if (final) {
                var _this$props$getScroll3,
                  _this$props$getScroll4,
                  _this$props5;

                this.forcedPlacement = final.placement;
                this.position = { ...POPPER_PLACEMENT[final.placement] };

                if (
                  final.leftOffset &&
                  "left" in this.position &&
                  this.position.left === "0"
                ) {
                  this.position.left = `${final.leftOffset}px`;
                }

                this.detachedFromTargetPosition = {
                  top: `${window.pageYOffset + final.rect.top}px`,
                  left: `${
                    window.pageXOffset + final.rect.left + final.leftOffset
                  }px`,
                };
                const scrollContainers =
                  (_this$props$getScroll3 =
                    (_this$props$getScroll4 = (_this$props5 = this.props)
                      .getScrollContainers) === null ||
                    _this$props$getScroll4 === void 0
                      ? void 0
                      : _this$props$getScroll4
                          .call(_this$props5)
                          .filter(Boolean)) !== null &&
                  _this$props$getScroll3 !== void 0
                    ? _this$props$getScroll3
                    : [];

                if (!this.isScrollListenerSetUp) {
                  scrollContainers.forEach((scrollContainer) => {
                    scrollContainer.addEventListener(
                      "scroll",
                      this.updatePlacement,
                      {
                        passive: true,
                      }
                    );
                  });
                  this.isScrollListenerSetUp = true;
                }
              }
            };
          },
        }
      ))),
      _class2))
  ) || _class);

class DetachedPopperContent extends React.Component {
  constructor() {
    super(...arguments);
    this.dom = null;

    this.onKeyDown = (event) => {
      if (event.keyCode === Keys.ESCAPE) {
        this.props.onEscape(event, this.dom);
      }
    };
  }

  componentDidMount() {
    var _this$dom, _this$dom2;

    // eslint-disable-next-line react/no-find-dom-node
    this.dom = ReactDOM.findDOMNode(this);
    (_this$dom = this.dom) === null || _this$dom === void 0
      ? void 0
      : _this$dom.addEventListener("click", this.context.ignoreRootClose); // keydown is only dispatched on certain types of elements, hence the necessary
    // cast (I think).
    // https://developer.mozilla.org/en-US/docs/Web/API/Element/keydown_event

    (_this$dom2 = this.dom) === null || _this$dom2 === void 0
      ? void 0
      : _this$dom2.addEventListener("keydown", this.onKeyDown);
  }

  componentWillUnmount() {
    if (this.dom) {
      this.dom.removeEventListener("click", this.context.ignoreRootClose);
      this.dom.removeEventListener("keydown", this.onKeyDown);
      this.dom = null;
    }
  }

  render() {
    return React.Children.only(this.props.children);
  }
}

DetachedPopperContent.contextType = RootCloseWrapperContext;
//# sourceMappingURL=popper.react-component.js.map
