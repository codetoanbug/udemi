import _initializerDefineProperty from "@babel/runtime/helpers/initializerDefineProperty";
import _applyDecoratedDescriptor from "@babel/runtime/helpers/applyDecoratedDescriptor";
import _initializerWarningHelper from "@babel/runtime/helpers/initializerWarningHelper";
var _class, _descriptor, _descriptor2, _descriptor3;
import { action, observable, runInAction, toJS, computed } from "mobx";
import { generateTrackingId } from "@udemy/event-tracking";
import { udExpiringLocalStorage, udPerformance } from "@udemy/shared-utils";
import { udApi, getHttpCacheHeaders } from "@udemy/ud-api";
import { CommandQueue } from "./command-queue";
import { shoppingConfig } from "./config";
export let ShoppingStorage =
  ((_class = class ShoppingStorage {
    constructor() {
      var _this$storage$get,
        _this = this;
      this.defaultState = {
        etag: null,
        credit: {
          amount: 0,
        },
        discounts: observable.array(),
        lists: {
          cart: observable.array(),
          express: observable.array(),
          saved_for_later: observable.array(),
          wishlist: observable.array(),
        },
        unseenCounts: {
          cart: 0,
          express: 0,
          saved_for_later: 0,
          wishlist: 0,
        },
        userId: null,
        availableCoupons: [],
      };
      this.now = new Date();
      this.expirationDate = new Date(this.now.setDate(this.now.getDate() + 30));
      this.storage = udExpiringLocalStorage(
        "shoppingCartStorage",
        "storage-1.0",
        this.expirationDate
      );
      this.state = observable({
        ...((_this$storage$get = this.storage.get("state")) !== null &&
        _this$storage$get !== void 0
          ? _this$storage$get
          : this.defaultState),
      });
      this.queue = new CommandQueue();
      this.status = observable.box(shoppingConfig.storage.status.notReady);
      _initializerDefineProperty(
        this,
        "isShoppingCartFeatureEnabled",
        _descriptor,
        this
      );
      this.fetch = () => {
        if (
          !this.isShoppingCartFeatureEnabled ||
          (!this.state.userId && !this.state.etag)
        ) {
          runInAction(() => {
            this.status.set(shoppingConfig.storage.status.ready);
          });
          return Promise.resolve(true);
        }
        const udPerf = udPerformance();
        udPerf.start("_cartApi");
        const params = new URLSearchParams(window.location.search);
        return this.makeDeferredRequest({
          method: "get",
          url: shoppingConfig.urls.cartAPI,
          params: Object.fromEntries(params),
        })
          .then(
            action(() => {
              udPerf.end("_cartApi");
              this.status.set(shoppingConfig.storage.status.ready);
            })
          )
          .catch(
            action(() => {
              this.status.set(shoppingConfig.storage.status.unAvailable);
            })
          );
      };
      this.addItems = function (listName, items) {
        let extraContext =
          arguments.length > 2 && arguments[2] !== undefined
            ? arguments[2]
            : {};
        const request = {
          method: "post",
          url: _this.buildSessionUrl(listName),
          data: {
            buyables: items.map((item) => item.buyable),
            context: extraContext,
          },
        };
        const buildBuyablePairs = (buyable) => {
          return {
            id: buyable.id,
            buyable_object_type: buyable.buyable_object_type,
          };
        };
        const resolveConflicts = (req, results) => {
          const serverBuyables = results[listName].map((item) =>
            buildBuyablePairs(item.buyable)
          );
          const isInResults = (_ref) => {
            let { id, buyable_object_type: type } = _ref;
            return !!serverBuyables.find((buyable) => {
              return buyable.id === id && buyable.buyable_object_type === type;
            });
          };
          req.data.buyables = req.data.buyables.filter(
            (buyable) => !isInResults(buildBuyablePairs(buyable))
          );
          return req.data.buyables.length === 0;
        };
        return _this.makeDeferredRequest(request, resolveConflicts);
      };
      this.removeItem = (listName, item) => {
        const buyable = item.buyable;
        const request = {
          method: "delete",
          params: {
            boId: buyable.id,
            boType: buyable.buyable_object_type,
          },
          url: this.buildSessionUrl(listName),
        };
        const resolveConflicts = (req, results) => {
          var _results$listName;
          const serverBuyables = (
            (_results$listName = results[listName]) !== null &&
            _results$listName !== void 0
              ? _results$listName
              : []
          ).map((item) => item.buyable);
          const findType =
            req.params[shoppingConfig.urlParams.buyableObjectType];
          const findId = req.params[shoppingConfig.urlParams.buyableObjectId];
          const existing = serverBuyables.find((buyable) => {
            return (
              buyable.buyable_object_type === findType && buyable.id === findId
            );
          });
          return !existing;
        };
        return this.makeDeferredRequest(request, resolveConflicts);
      };
      this.applyDiscounts = function () {
        let codes =
          arguments.length > 0 && arguments[0] !== undefined
            ? arguments[0]
            : [];
        const resolveConflicts = (req, results) => {
          const resultCodes = results.discount_attempts.map((c) => c.code);
          const existing = codes.every((code) => resultCodes.includes(code));
          return Boolean(existing);
        };
        return _this.makeDeferredRequest(
          {
            method: "post",
            data: {
              codes,
            },
            url: _this.buildSessionUrl("discounts"),
          },
          resolveConflicts
        );
      };
      this.removeDiscounts = (codes) =>
        this.makeDeferredRequest({
          method: "delete",
          params: {
            codes: codes.join(","),
          },
          url: this.buildSessionUrl("discounts"),
        });
      /*
       * This call occurs outside of all other modifications; we want it to complete ASAP.
       */
      this.clearDiscounts = () =>
        this.makeRequest({
          method: "delete",
          url: this.buildSessionUrl("discounts"),
        });
      /*
       * Checkout
       */
      this.createExpressCheckoutSession = (items, codes) => {
        const request = {
          method: "post",
          data: {
            buyables: items.map((item) => item.buyable),
          },
          url: shoppingConfig.urls.expressCheckoutAPI,
        };
        if (codes) {
          request.data.codes = codes;
        }
        return this.makeRequest(request);
      };
      _initializerDefineProperty(this, "transformResponse", _descriptor2, this);
      this.createShoppingError = (httpError) => {
        var _httpError$response, _httpError$response2, _httpError$response3;
        return Promise.reject({
          canBeResolved:
            ((_httpError$response = httpError.response) === null ||
            _httpError$response === void 0
              ? void 0
              : _httpError$response.status) === 412 ||
            ((_httpError$response2 = httpError.response) === null ||
            _httpError$response2 === void 0
              ? void 0
              : _httpError$response2.status) === 409,
          httpResponse: httpError.response,
          refetchedData:
            (_httpError$response3 = httpError.response) === null ||
            _httpError$response3 === void 0
              ? void 0
              : _httpError$response3.data,
        });
      };
      this.updateHeaders = (request) => {
        var _request$method;
        // Update headers
        request.headers = request.headers || {};
        if (
          ((_request$method = request.method) === null ||
          _request$method === void 0
            ? void 0
            : _request$method.toLowerCase()) === "get"
        ) {
          // enable HTTP caching
          request.headers = {
            ...request.headers,
            ...getHttpCacheHeaders(),
          };
          request.params = {
            ...request.params,
            sessionState: this.state.etag || "",
          };
        } else if (this.state.etag) {
          request.headers["If-Match"] = this.state.etag;
        }
      };
      _initializerDefineProperty(
        this,
        "updateStateOnSuccess",
        _descriptor3,
        this
      );
      /**
       * Fetch the cart every 90 minutes in the case of a stale tab
       * This prevents issue with adding to cart after being inactive on a tab
       * on a Udemy page due to stale cart session (ie. SessionOutdated)
       */
      setInterval(() => {
        this.fetch();
      }, 5400000);
    }
    get credit() {
      return this.state.credit;
    }
    get discounts() {
      return this.state.discounts;
    }
    get lists() {
      return this.state.lists;
    }
    get availableCoupons() {
      return this.state.availableCoupons;
    }
    setUserId(id) {
      this.state.userId = id;
    }
    setIsFeatureEnabled(isEnabled) {
      this.isShoppingCartFeatureEnabled = isEnabled;
    }
    makeDeferredRequest(
      request,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      conflictResolver
    ) {
      const commandResolver = (command, requestError) => {
        if (!requestError.canBeResolved) {
          command.actions.reject(requestError);
          return;
        }
        const conflictsResolved =
          conflictResolver === null || conflictResolver === void 0
            ? void 0
            : conflictResolver(request, requestError.refetchedData);
        if (conflictsResolved) {
          this.updateStateOnSuccess(requestError.refetchedData);
          command.actions.resolve(true);
        } else {
          command.actions.retry(requestError);
        }
      };
      return this.queue.add(() => this.makeRequest(request), commandResolver);
    }
    makeRequest(request) {
      this.updateHeaders(request);
      return udApi
        .request(request)
        .then(this.transformResponse)
        .catch((httpError) => {
          this.transformResponse(httpError.response);
          throw httpError;
        })
        .then(this.updateStateOnSuccess, this.createShoppingError);
    }
    buildSessionUrl(resourceName) {
      return `${shoppingConfig.urls.cartAPI}${resourceName.replace(
        /_/g,
        "-"
      )}/`;
    }
  }),
  ((_descriptor = _applyDecoratedDescriptor(
    _class.prototype,
    "isShoppingCartFeatureEnabled",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return true;
      },
    }
  )),
  _applyDecoratedDescriptor(
    _class.prototype,
    "credit",
    [computed],
    Object.getOwnPropertyDescriptor(_class.prototype, "credit"),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "discounts",
    [computed],
    Object.getOwnPropertyDescriptor(_class.prototype, "discounts"),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "lists",
    [computed],
    Object.getOwnPropertyDescriptor(_class.prototype, "lists"),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "availableCoupons",
    [computed],
    Object.getOwnPropertyDescriptor(_class.prototype, "availableCoupons"),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "setUserId",
    [action],
    Object.getOwnPropertyDescriptor(_class.prototype, "setUserId"),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "setIsFeatureEnabled",
    [action],
    Object.getOwnPropertyDescriptor(_class.prototype, "setIsFeatureEnabled"),
    _class.prototype
  ),
  (_descriptor2 = _applyDecoratedDescriptor(
    _class.prototype,
    "transformResponse",
    [action],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return (response) => {
          if (response.headers && response.headers.etag !== this.state.etag) {
            runInAction(() => {
              this.state.etag = response.headers.etag;
            });
          }
          return response;
        };
      },
    }
  )),
  (_descriptor3 = _applyDecoratedDescriptor(
    _class.prototype,
    "updateStateOnSuccess",
    [action],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return (response) => {
          var _response$data$availa;
          if (!response || !response.data) {
            return Promise.resolve(false);
          }
          this.state.discounts.clear();
          this.state.discounts.replace(response.data.discount_attempts);
          this.state.credit.amount = response.data.user.id
            ? response.data.user.credit.amount
            : 0;
          this.state.availableCoupons =
            ((_response$data$availa = response.data.available_coupon_info) ===
              null || _response$data$availa === void 0
              ? void 0
              : _response$data$availa.coupons) || [];
          shoppingConfig.shoppingListTypes.forEach((listName) => {
            this.state.lists[listName].clear();
            const list = response.data[listName];
            if (list) {
              attachFrontendTrackingIds(list.map((item) => item.buyable));
            }
            this.state.lists[listName].replace(response.data[listName]);
            this.state.unseenCounts[listName] =
              response.data[`${listName}_unseen_count`] || 0;
          });
          this.storage.set("state", toJS(this.state));
          return Promise.resolve(true);
        };
      },
    }
  ))),
  _class);

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function attachFrontendTrackingIds(items) {
  // Utility method for attaching frontend tracking IDs to data from APIs
  items
    // We don't want to regenerate ID's for the item
    .filter((item) => !item.frontendTrackingId)
    .forEach((item) => {
      item.frontendTrackingId = generateTrackingId();
    });
}
//# sourceMappingURL=shopping-storage.js.map
