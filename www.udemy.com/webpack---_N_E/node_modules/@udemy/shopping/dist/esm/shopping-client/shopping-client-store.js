import _applyDecoratedDescriptor from "@babel/runtime/helpers/applyDecoratedDescriptor";
var _class;
import { action, computed, observable } from "mobx";
import {
  udExpiringLocalStorage,
  isMobileApp,
  NativeAppWebviewBridge,
} from "@udemy/shared-utils";
import { shoppingConfig } from "./config";
import { getMessagingStore } from "./messaging-store";
import { OnEnrolledMessage } from "./on-enrolled-message";
import { ShoppingDiscounts } from "./shopping-discounts";
import { ShoppingList } from "./shopping-list";
function assertValue(value) {
  let valueName =
    arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "value";
  if (!value) {
    throw new Error(`Attempting to access ${valueName} before is has been set`);
  }
  return value;
}
const NOTICES_API_RELOAD_KEY = "reload";
export let ShoppingClientStore =
  ((_class = class ShoppingClientStore {
    constructor(storage) {
      this.storage = storage;
      this.NOTICE_REFRESH_EXPIRATION_DATE = new Date(
        Date.now() + 10 * 60 * 1000
      );
      this.noticesApiLocalStorage = udExpiringLocalStorage(
        "notices",
        "api",
        this.NOTICE_REFRESH_EXPIRATION_DATE
      );
      this.webviewBridge = new NativeAppWebviewBridge();
      this.removeDiscountPromise = null;
      this.userId = void 0;
      this.state = void 0;
      this.couponStore = null;
      this._i18n = void 0;
      this._udLink = void 0;
      this.state = {
        credit: this.storage.credit,
        discounts: new ShoppingDiscounts(this.storage.discounts),
        lists: {
          cart: new ShoppingList("cart", this.storage.lists.cart),
          wishlist: new ShoppingList("wishlist", storage.lists.wishlist),
          saved_for_later: new ShoppingList(
            "saved_for_later",
            storage.lists.saved_for_later
          ),
          express: new ShoppingList("express", storage.lists.express),
          checkout: new ShoppingList("checkout", observable.array()),
        },
      };

      // populate checkout list from frozen data if available
      try {
        var _JSON$parse;
        const storedCheckoutItems =
          window.sessionStorage.getItem("checkoutItems");
        const items =
          (_JSON$parse = JSON.parse(storedCheckoutItems)) !== null &&
          _JSON$parse !== void 0
            ? _JSON$parse
            : [];
        this.state.lists.checkout = new ShoppingList("checkout", items);
      } catch (error) {
        this.state.lists.checkout = new ShoppingList(
          "checkout",
          observable.array()
        );
      }
    }
    initialize(options) {
      this._i18n = options.i18n;
      this._udLink = options.udLink;
      this.storage.setIsFeatureEnabled(options.isShoppingCartFeatureEnabled);
    }
    get i18n() {
      return assertValue(this._i18n);
    }
    get udLink() {
      return assertValue(this._udLink);
    }
    get credit() {
      return this.state.credit;
    }
    get discounts() {
      return this.state.discounts;
    }
    get lists() {
      return this.state.lists;
    }
    get status() {
      return this.storage.status;
    }
    get availableCoupons() {
      return this.storage.availableCoupons;
    }
    get hasPendingOperations() {
      return Object.keys(this.state.lists).some(
        (listName) => this.state.lists[listName].hasPendingOperations
      );
    }
    setUserId(id) {
      this.userId = id;
      this.storage.setUserId(id);
    }
    addToList(listName, buyables) {
      let context =
        arguments.length > 2 && arguments[2] !== undefined
          ? arguments[2]
          : null;
      const items = Object.values(buyables).map((buyable) => ({
        buyable: {
          buyable_object_type: buyable.buyable_object_type,
          id: buyable.id,
        },
      }));
      return this.storage.addItems(listName, items, context).then(() => {
        if (["cart", "wishlist"].includes(listName)) {
          this.noticesApiLocalStorage = udExpiringLocalStorage(
            "notices",
            "api"
          );
          this.noticesApiLocalStorage.delete(NOTICES_API_RELOAD_KEY);
        }
      });
    }
    cancelCheckout() {
      getMessagingStore("notifications").sendMessage("checkoutCancel");
    }
    notify(reason) {
      let options =
        arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      const message = {
        message: typeof reason === "string" ? reason : reason.message,
        options,
      };
      getMessagingStore("notifications").sendMessage(message);
    }
    removeFromList(listName, item) {
      const afterRemove = () => {
        this.state.lists[listName].remove(item);
        if (this.couponStore) {
          this.couponStore.updateDiscountState();
        }
        if (
          ["cart", "wishlist"].includes(listName) &&
          this.state.lists[listName].isEmpty
        ) {
          this.noticesApiLocalStorage.set(NOTICES_API_RELOAD_KEY, true);
        }
      };
      return this.storage
        .removeItem(listName, item)
        .then(() => {
          afterRemove();
          return Promise.resolve(true);
        })
        .catch(() => {
          this.state.lists[listName].add(item)();
          afterRemove();
          return Promise.reject(false);
        });
    }
    moveToList(srcName, destName, item) {
      const postAddItems = () => {
        this.state.lists[destName].add(item);
        this.state.lists[srcName].remove(item);
        if (this.couponStore) {
          this.couponStore.updateDiscountState();
        }
      };
      return this.storage
        .addItems(destName, [item])
        .then(() => {
          postAddItems();
          return Promise.resolve(true);
        })
        .catch(() => {
          postAddItems();
          return Promise.reject(false);
        });
    }
    fetch() {
      return this.storage.fetch();
    }

    /*
     * Discounts
     */
    applyDiscounts(codes) {
      if (!codes || !codes.length) {
        return Promise.resolve(true);
      }
      const discountCodes = codes.map((c) => c.toUpperCase());
      return this.storage.applyDiscounts(discountCodes);
    }
    removeDiscounts(codes) {
      if (!codes || !codes.length) {
        return Promise.resolve(true);
      }
      return this.storage.removeDiscounts(codes);
    }
    validateDiscounts() {
      if (this.removeDiscountPromise) {
        return this.removeDiscountPromise;
      }
      const notApplicableCodes = {};
      const setNotApplicableCodes = (key, codes) => {
        if (codes.length > 0) {
          notApplicableCodes[key] = codes;
        }
      };
      setNotApplicableCodes("invalid", this.state.discounts.invalidCodes);
      setNotApplicableCodes("expired", this.state.discounts.expiredCodes);
      setNotApplicableCodes("sold_out", this.state.discounts.soldOutCodes);
      Object.entries(notApplicableCodes).forEach((_ref) => {
        let [type, codes] = _ref;
        const errors = shoppingConfig.errors(this.i18n.gettext);
        const typeKey = type;
        const string =
          errors.discount[typeKey][codes.length > 1 ? "plural" : "singular"];
        const message = this.i18n.interpolate(
          string,
          {
            code: codes.join(", "),
          },
          true
        );
        this.notify(message, {
          reason: type,
        });
      });
      this.removeDiscountPromise = this.removeDiscounts(
        [].concat(...Object.values(notApplicableCodes))
      );
      return this.removeDiscountPromise.then((result) => {
        this.removeDiscountPromise = null;
        return result;
      });
    }

    /*
     * Checkout
     */
    get isCheckoutAvailable() {
      return Boolean(
        this.state.lists.checkout &&
          !this.state.lists.checkout.isEmpty &&
          this.userId
      );
    }

    /**
     * Freezes a list into a separate "checkout" list.
     *
     * This method *must* be called before checkout can be attempted.
     */
    freezeCheckoutList(listName) {
      this.state.lists.checkout.setItems([...this.state.lists[listName].items]);
      window.sessionStorage.setItem(
        "checkoutItems",
        JSON.stringify(this.state.lists.checkout.items)
      );
    }

    /**
     * Completes the checkout process, reverting checkout state to initial values.
     *
     * @param data - Information about completed checkout. Must have a gatewayTransactionid property.
     */
    completeCheckout(data) {
      const boughtBuyables = this.state.lists.checkout.items.map((item) => {
        return item.buyable;
      });
      this.resetCheckoutList();
      return this.storage.clearDiscounts().then(() => {
        this.performTerminalAction(data, boughtBuyables);
      });
    }
    setExpressCheckoutListFromItem(item) {
      this.resetCheckoutList();
      const buyables = [
        {
          buyable: {
            id: item.buyableObjectId,
            buyable_object_type: item.buyableObjectType,
          },
        },
      ];
      const codes = item.codes;
      return this.storage
        .createExpressCheckoutSession(buyables, codes)
        .then(() => {
          this.freezeCheckoutList("express");
          return Promise.resolve(true);
        });
    }

    /**
     * Return purchase information about the current checkout state.
     * Requires that the client's checkout state is at least "Available".
     *
     * Returns an object in format:
     * {
     *   isPaymentRequired: true iff checkout list price is greater than user's current credit
     *   items: items in current checkout list
     * }
     */
    getCheckoutData() {
      return new Promise((resolve) => {
        return resolve({
          isPaymentRequired:
            this.isCheckoutAvailable &&
            this.state.lists.checkout.purchasePriceAmount -
              this.state.credit.amount >
              0,
          items: this.createCheckoutAttemptData(this.state.lists.checkout),
        });
      });
    }
    getTotalDue() {
      return Math.max(
        this.lists.checkout.purchasePriceAmount - this.credit.amount,
        0
      );
    }
    resetCheckoutList() {
      this.state.lists.checkout.clear();
      window.sessionStorage.removeItem("checkoutItems");
    }

    /**
     * Last step process called when everything else has been completed.
     * This supports different workflows for different devices
     *
     * @param data - Information about completed checkout. Must have a gatewayTransactionid property.
     * @param buyables - List of buyable objects
     */
    performTerminalAction(data, buyables) {
      if (isMobileApp()) {
        this.webviewBridge.sendMessage(
          new OnEnrolledMessage(buyables, data.purchasePrice.price.toString())
        );
      } else {
        const successUrl = data.redirect_url
          ? data.redirect_url
          : this.udLink.to(
              shoppingConfig.urls.paymentSuccessPage(data.gatewayTransactionId)
            );
        window.location.href = successUrl;
      }
    }
    createCheckoutAttemptData(list) {
      const items = list.items.map((item) => {
        let itemDiscount = undefined;
        if (item.current_discount && item.current_discount.code) {
          itemDiscount = {
            code: item.current_discount.code,
          };
        }
        const data = {
          discountInfo: itemDiscount,
          purchasePrice: item.purchase_price,
        };
        let buyable = item.buyable;
        if (item.buyable.buyable_object_type === "license") {
          data.licenseId = item.buyable.id;
          buyable = item.buyable.course;
        } else if (item.buyable.buyable_object_type === "gift") {
          data.giftId = item.buyable.id;
          buyable = item.buyable.course;
        }

        // TODO: add course invite and course password support
        data.buyableType = buyable.buyable_object_type;
        data.buyableId = buyable.id;
        return data;
      });
      return {
        items,
      };
    }
  }),
  (_applyDecoratedDescriptor(
    _class.prototype,
    "credit",
    [computed],
    Object.getOwnPropertyDescriptor(_class.prototype, "credit"),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "discounts",
    [computed],
    Object.getOwnPropertyDescriptor(_class.prototype, "discounts"),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "lists",
    [computed],
    Object.getOwnPropertyDescriptor(_class.prototype, "lists"),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "status",
    [computed],
    Object.getOwnPropertyDescriptor(_class.prototype, "status"),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "availableCoupons",
    [computed],
    Object.getOwnPropertyDescriptor(_class.prototype, "availableCoupons"),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "hasPendingOperations",
    [computed],
    Object.getOwnPropertyDescriptor(_class.prototype, "hasPendingOperations"),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "setUserId",
    [action],
    Object.getOwnPropertyDescriptor(_class.prototype, "setUserId"),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "isCheckoutAvailable",
    [computed],
    Object.getOwnPropertyDescriptor(_class.prototype, "isCheckoutAvailable"),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "getTotalDue",
    [action],
    Object.getOwnPropertyDescriptor(_class.prototype, "getTotalDue"),
    _class.prototype
  )),
  _class);
//# sourceMappingURL=shopping-client-store.js.map
