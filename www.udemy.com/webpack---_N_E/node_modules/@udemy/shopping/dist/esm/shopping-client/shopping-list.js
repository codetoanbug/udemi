import _initializerDefineProperty from "@babel/runtime/helpers/initializerDefineProperty";
import _initializerWarningHelper from "@babel/runtime/helpers/initializerWarningHelper";
import _applyDecoratedDescriptor from "@babel/runtime/helpers/applyDecoratedDescriptor";
var _class, _descriptor, _descriptor2, _descriptor3, _descriptor4;
import { action, computed, observable, runInAction } from "mobx";
/*
 * Internal data structure for use in shopping-client.js.
 *
 * When working with the shopping-session API, there are many cases where the user
 * has "queued up" actions to perform. As success / fail results come back, the
 * server's "current state" is out-of-date compared to the user's interface. This object
 * acts as a buffer between these two states, allowing the user to make modifications
 * more quickly than the shopping storage can process them.
 *
 * Basic operation: stores additions and removals as applied by user
 *
 */
export let ShoppingList =
  ((_class = class ShoppingList {
    constructor(name, initialItems, unseenCount) {
      this.state = void 0;
      _initializerDefineProperty(this, "setItems", _descriptor, this);
      _initializerDefineProperty(this, "add", _descriptor2, this);
      _initializerDefineProperty(this, "remove", _descriptor3, this);
      _initializerDefineProperty(this, "clear", _descriptor4, this);
      this.state = observable({
        name,
        addAttempts: observable.array(),
        removeAttempts: observable.array(),
        items:
          initialItems !== null && initialItems !== void 0
            ? initialItems
            : observable.array(),
        unseenCount: observable.box(
          unseenCount !== null && unseenCount !== void 0 ? unseenCount : 0
        ),
      });
    }
    finishAttempt(item, list) {
      return action(() => {
        // only remove a single item occurrence from the list, in case the item
        // has been moved multiple times between API calls
        const itemToRemove = list.find((t) => t.buyable.id === item.buyable.id);
        if (itemToRemove) {
          list.remove(itemToRemove);
        }
      });
    }
    get name() {
      return this.state.name;
    }
    get unseenCount() {
      return this.state.unseenCount.get();
    }
    set unseenCount(value) {
      runInAction(() => {
        this.state.unseenCount.set(value);
      });
    }

    /*
     * The current set of items in the list, with pending modifications applied.
     */
    get items() {
      // track # of "occurrences" of each buyableId in a map; e.g. {123: 1, 456: 3}
      // Note: we count "exists in state.items array" as 1 occurrence
      const getBuyableIdCounts = (items) => {
        const counts = {};
        items.forEach((item) => {
          const id = item.buyable.id;
          counts[id] = (counts[id] || 0) + 1;
        });
        return counts;
      };
      const itemCounts = getBuyableIdCounts(this.state.items);
      const addCounts = getBuyableIdCounts(this.state.addAttempts);
      const removeCounts = getBuyableIdCounts(this.state.removeAttempts);

      // Return any item that has been added more times than it has been removed
      const seenItems = new Set();
      const possibleItems = [];
      this.state.addAttempts.concat(this.state.items).forEach((item) => {
        const id = item.buyable.id;
        if (!seenItems.has(id)) {
          seenItems.add(id);
          const totalCount =
            (itemCounts[id] || 0) +
            (addCounts[id] || 0) -
            (removeCounts[id] || 0);
          if (totalCount > 0) {
            possibleItems.push(item);
          }
        }
      });
      return possibleItems;
    }
    get isEmpty() {
      return this.items.length === 0;
    }
    findItemByBuyable(type, id) {
      return (
        this.items.find(
          (item) =>
            item.buyable &&
            item.buyable.buyable_object_type === type &&
            item.buyable.id === id
        ) || null
      );
    }
    hasBuyable(type, id) {
      return Boolean(this.findItemByBuyable(type, id));
    }
    hasBuyables(buyables) {
      return (
        buyables.length > 0 &&
        buyables.every((e) => this.hasBuyable(e.buyable_object_type, e.id))
      );
    }
    get hasPendingOperations() {
      return (
        this.state.addAttempts.length > 0 ||
        this.state.removeAttempts.length > 0
      );
    }
    get purchasePriceAmount() {
      return price(this.items, "purchase_price");
    }
    get listPriceAmount() {
      return price(this.items, "list_price");
    }
    get discountAmount() {
      const discountPrices = this.items
        .filter(
          (item) => item.current_discount && item.current_discount.saving_price
        )
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        .map((item) => item.current_discount);
      if (!discountPrices.length) {
        return 0;
      }
      return -price(discountPrices, "saving_price");
    }
    get discountPercentage() {
      const listPriceAmount = this.listPriceAmount;
      return listPriceAmount
        ? Math.round(100 * (1 - this.purchasePriceAmount / listPriceAmount))
        : 0;
    }
  }),
  (_applyDecoratedDescriptor(
    _class.prototype,
    "name",
    [computed],
    Object.getOwnPropertyDescriptor(_class.prototype, "name"),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "unseenCount",
    [computed],
    Object.getOwnPropertyDescriptor(_class.prototype, "unseenCount"),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "items",
    [computed],
    Object.getOwnPropertyDescriptor(_class.prototype, "items"),
    _class.prototype
  ),
  (_descriptor = _applyDecoratedDescriptor(
    _class.prototype,
    "setItems",
    [action],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return (newItems) => {
          this.state.items.clear();
          this.state.items.replace(newItems);
        };
      },
    }
  )),
  _applyDecoratedDescriptor(
    _class.prototype,
    "isEmpty",
    [computed],
    Object.getOwnPropertyDescriptor(_class.prototype, "isEmpty"),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "hasPendingOperations",
    [computed],
    Object.getOwnPropertyDescriptor(_class.prototype, "hasPendingOperations"),
    _class.prototype
  ),
  (_descriptor2 = _applyDecoratedDescriptor(_class.prototype, "add", [action], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function () {
      return (item) => {
        this.state.addAttempts.unshift(item);
        return this.finishAttempt(item, this.state.addAttempts);
      };
    },
  })),
  (_descriptor3 = _applyDecoratedDescriptor(
    _class.prototype,
    "remove",
    [action],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return (item) => {
          this.state.removeAttempts.push(item);
          return this.finishAttempt(item, this.state.removeAttempts);
        };
      },
    }
  )),
  (_descriptor4 = _applyDecoratedDescriptor(
    _class.prototype,
    "clear",
    [action],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return () => {
          this.state.items.clear();
          this.state.addAttempts.clear();
          this.state.removeAttempts.clear();
        };
      },
    }
  )),
  _applyDecoratedDescriptor(
    _class.prototype,
    "purchasePriceAmount",
    [computed],
    Object.getOwnPropertyDescriptor(_class.prototype, "purchasePriceAmount"),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "listPriceAmount",
    [computed],
    Object.getOwnPropertyDescriptor(_class.prototype, "listPriceAmount"),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "discountAmount",
    [computed],
    Object.getOwnPropertyDescriptor(_class.prototype, "discountAmount"),
    _class.prototype
  ),
  _applyDecoratedDescriptor(
    _class.prototype,
    "discountPercentage",
    [computed],
    Object.getOwnPropertyDescriptor(_class.prototype, "discountPercentage"),
    _class.prototype
  )),
  _class);
function price(items, priceType) {
  return items.reduce((total, item) => {
    var _item$priceType;
    return (
      total +
      parseFloat(
        String(
          (_item$priceType = item[priceType]) === null ||
            _item$priceType === void 0
            ? void 0
            : _item$priceType.amount
        )
      )
    );
  }, 0);
}
//# sourceMappingURL=shopping-list.js.map
