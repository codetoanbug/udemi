import _initializerDefineProperty from "@babel/runtime/helpers/initializerDefineProperty";
import _applyDecoratedDescriptor from "@babel/runtime/helpers/applyDecoratedDescriptor";
import _initializerWarningHelper from "@babel/runtime/helpers/initializerWarningHelper";
var _class, _descriptor, _descriptor2, _descriptor3;
import { action, autorun, observable, computed } from "mobx";
/**
 * Represents a queue of deferred behavior, represented by promises.
 * Each command is run sequentially, and its associated promise is then resolved / rejected.
 *
 * Note: Commands are also retried (up to a limit defined in the configuration),
 * with retries handled by the the commamnd's ``resolver`` function.
 */
export let CommandQueue =
  ((_class = class CommandQueue {
    constructor() {
      let retryLimit =
        arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;
      this.retryLimit = retryLimit;
      _initializerDefineProperty(this, "commands", _descriptor, this);
      _initializerDefineProperty(this, "add", _descriptor2, this);
      _initializerDefineProperty(this, "endCurrent", _descriptor3, this);
      /**
       * Let's trigger new command in the queue when it is ready and there is
       * at least an element.
       */

      autorun(() => {
        if (this.currentCommand) {
          this.currentCommand.run();
        }
      });
    }
    get currentCommand() {
      return this.commands.length > 0 ? this.commands[0] : null;
    }
  }),
  ((_descriptor = _applyDecoratedDescriptor(
    _class.prototype,
    "commands",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [];
      },
    }
  )),
  _applyDecoratedDescriptor(
    _class.prototype,
    "currentCommand",
    [computed],
    Object.getOwnPropertyDescriptor(_class.prototype, "currentCommand"),
    _class.prototype
  ),
  (_descriptor2 = _applyDecoratedDescriptor(_class.prototype, "add", [action], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function () {
      return (command, resolver) => {
        const cmd = deferredCommand(
          command,
          resolver,
          this.retryLimit,
          this.endCurrent
        );
        this.commands.push(cmd);
        return cmd.promise;
      };
    },
  })),
  (_descriptor3 = _applyDecoratedDescriptor(
    _class.prototype,
    "endCurrent",
    [action],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return () => {
          this.commands.shift();
        };
      },
    }
  ))),
  _class);

/**
 * Represents a set of behavior to be run & retried.
 *
 * @param command - deferred behavior
 * @param resolver - function that accepts (command, error) and calls one of:
 *                     + command.actions.resolve(data)
 *                     + command.actions.reject(err)
 *                     + command.actions.retry(err)
 * @param retryLimit - maximum number of times to retry `command`.
 * @param onComplete - function to be run BEFORE the command's associated promise is resolved.
 */
function deferredCommand(command, resolver, retryLimit, onComplete) {
  const state = {
    deferred: createDeferred(),
    command: action(command),
    resolver,
    triesLeft: retryLimit,
    onComplete,
  };
  const cmd = {
    promise: state.deferred.promise,
    actions: {
      resolve: (data) => {
        state.onComplete();
        state.deferred.resolve(data);
      },
      reject: (err) => {
        state.onComplete();
        state.deferred.reject(err);
      },
      retry: action((err) => {
        state.triesLeft--;
        if (state.triesLeft > 0) {
          return cmd.run();
        }
        state.onComplete();
        state.deferred.reject(err);
      }),
    },
    run: action(() => {
      command().then(cmd.actions.resolve, (err) => state.resolver(cmd, err));
    }),
  };
  return cmd;
}
function createDeferred() {
  const deferred = {};
  deferred.promise = new Promise((resolve, reject) => {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
}
//# sourceMappingURL=command-queue.js.map
