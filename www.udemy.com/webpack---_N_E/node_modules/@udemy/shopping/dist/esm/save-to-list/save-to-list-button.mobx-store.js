import _initializerDefineProperty from "@babel/runtime/helpers/initializerDefineProperty";
import _applyDecoratedDescriptor from "@babel/runtime/helpers/applyDecoratedDescriptor";
import _initializerWarningHelper from "@babel/runtime/helpers/initializerWarningHelper";
var _class,
  _descriptor,
  _descriptor2,
  _descriptor3,
  _descriptor4,
  _descriptor5,
  _descriptor6,
  _descriptor7,
  _descriptor8,
  _descriptor9,
  _descriptor10,
  _descriptor11,
  _descriptor12,
  _descriptor13,
  _descriptor14,
  _descriptor15,
  _descriptor16,
  _descriptor17,
  _descriptor18;
import { action, observable, computed, runInAction } from "mobx";
import { Tracker } from "@udemy/event-tracking";
import { ToasterStore } from "@udemy/react-messaging-components";
import { udApi } from "@udemy/ud-api";
import { ListEvents, MAX_TITLE_CHARACTER_LIMIT } from "./constants";
import {
  LearningListItemSaveEvent,
  LearningListCreateEvent,
  LearningListItemRemoveEvent,
} from "./events";
export let SaveToListButtonStore =
  ((_class = class SaveToListButtonStore {
    constructor(course, uiRegion, i18n) {
      this.course = course;
      this.uiRegion = uiRegion;
      this.i18n = void 0;
      // Modal properties
      _initializerDefineProperty(this, "isModalOpen", _descriptor, this);
      _initializerDefineProperty(this, "isFetchingData", _descriptor2, this);
      _initializerDefineProperty(this, "hasError", _descriptor3, this);
      _initializerDefineProperty(this, "isSubmitting", _descriptor4, this);
      // Learning list
      _initializerDefineProperty(this, "myList", _descriptor5, this);
      // Create list form
      _initializerDefineProperty(this, "newListTitle", _descriptor6, this);
      _initializerDefineProperty(this, "titleTooLong", _descriptor7, this);
      _initializerDefineProperty(
        this,
        "isNewListFormVisible",
        _descriptor8,
        this
      );
      _initializerDefineProperty(this, "isCreatingNewList", _descriptor9, this);
      _initializerDefineProperty(this, "setNewListTitle", _descriptor10, this);
      _initializerDefineProperty(this, "createList", _descriptor11, this);
      _initializerDefineProperty(
        this,
        "toggleNewListForm",
        _descriptor12,
        this
      );
      _initializerDefineProperty(this, "openModal", _descriptor13, this);
      _initializerDefineProperty(this, "hideModal", _descriptor14, this);
      _initializerDefineProperty(this, "toggleList", _descriptor15, this);
      _initializerDefineProperty(this, "removeFromList", _descriptor16, this);
      _initializerDefineProperty(this, "saveToList", _descriptor17, this);
      this.handleToaster = (message, body, style) => {
        const alertBannerProps = {
          udStyle: style !== null && style !== void 0 ? style : "success",
          title: message,
          body: body !== null && body !== void 0 ? body : "",
          showCta: false,
        };
        ToasterStore.addAlertBannerToast(alertBannerProps, {
          autoDismiss: true,
          autoDismissTimeout: 5000,
        });
      };
      _initializerDefineProperty(this, "fetchListData", _descriptor18, this);
      this.course = course;
      this.uiRegion = uiRegion;
      this.i18n = i18n;
    }
    get selectedList() {
      return this.myList.filter((list) => list.isSelected);
    }
  }),
  ((_descriptor = _applyDecoratedDescriptor(
    _class.prototype,
    "isModalOpen",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return false;
      },
    }
  )),
  (_descriptor2 = _applyDecoratedDescriptor(
    _class.prototype,
    "isFetchingData",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return false;
      },
    }
  )),
  (_descriptor3 = _applyDecoratedDescriptor(
    _class.prototype,
    "hasError",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return false;
      },
    }
  )),
  (_descriptor4 = _applyDecoratedDescriptor(
    _class.prototype,
    "isSubmitting",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return new Set();
      },
    }
  )),
  (_descriptor5 = _applyDecoratedDescriptor(
    _class.prototype,
    "myList",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [];
      },
    }
  )),
  (_descriptor6 = _applyDecoratedDescriptor(
    _class.prototype,
    "newListTitle",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return "";
      },
    }
  )),
  (_descriptor7 = _applyDecoratedDescriptor(
    _class.prototype,
    "titleTooLong",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return false;
      },
    }
  )),
  (_descriptor8 = _applyDecoratedDescriptor(
    _class.prototype,
    "isNewListFormVisible",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return false;
      },
    }
  )),
  (_descriptor9 = _applyDecoratedDescriptor(
    _class.prototype,
    "isCreatingNewList",
    [observable],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return false;
      },
    }
  )),
  (_descriptor10 = _applyDecoratedDescriptor(
    _class.prototype,
    "setNewListTitle",
    [action],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return (event) => {
          const title = event.target.value.trim();
          if (title.length > MAX_TITLE_CHARACTER_LIMIT) {
            this.titleTooLong = true;
          } else {
            this.newListTitle = title;
            this.titleTooLong = false;
          }
        };
      },
    }
  )),
  (_descriptor11 = _applyDecoratedDescriptor(
    _class.prototype,
    "createList",
    [action],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return async () => {
          const { gettext, interpolate } = this.i18n;
          this.isCreatingNewList = true;
          try {
            const response = await udApi.post(
              "/users/me/subscribed-courses-collections/",
              {
                title: this.newListTitle,
              }
            );
            runInAction(() => {
              response.data.isSelected = true;
              this.myList.push(response.data);
              if (response.status === 201) {
                Tracker.publishEvent(
                  new LearningListCreateEvent({
                    listId: response.data.list_id,
                    uiRegion: this.uiRegion,
                    nonInteraction: false,
                  })
                );
                this.saveToList(response.data.id, response.data.title);
                // Optimistically allow the UI to update immediately
                document.dispatchEvent(
                  new CustomEvent(ListEvents.CREATE, {
                    detail: {
                      collectionId: response.data.id,
                    },
                  })
                );
              }
            });
          } catch (err) {
            var _response;
            runInAction(() => {
              this.hasError = true;
            });
            const errData =
              (_response = err.response) === null || _response === void 0
                ? void 0
                : _response.data;
            const errMessage =
              ((errData === null || errData === void 0
                ? void 0
                : errData.results) &&
                errData.results[0]) ||
              (errData === null || errData === void 0
                ? void 0
                : errData.detail);
            this.handleToaster(
              interpolate(
                gettext("Failed to save to %(listTitle)s"),
                {
                  listTitle: this.newListTitle,
                },
                true
              ),
              errMessage,
              "error"
            );
          } finally {
            runInAction(() => {
              this.newListTitle = "";
              this.isNewListFormVisible = false;
              this.isCreatingNewList = false;
            });
          }
        };
      },
    }
  )),
  (_descriptor12 = _applyDecoratedDescriptor(
    _class.prototype,
    "toggleNewListForm",
    [action],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return () => {
          this.isNewListFormVisible = !this.isNewListFormVisible;
        };
      },
    }
  )),
  (_descriptor13 = _applyDecoratedDescriptor(
    _class.prototype,
    "openModal",
    [action],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return () => {
          this.isModalOpen = true;
        };
      },
    }
  )),
  (_descriptor14 = _applyDecoratedDescriptor(
    _class.prototype,
    "hideModal",
    [action],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return () => {
          this.hasError = false;
          this.myList = [];
          this.isModalOpen = false;
        };
      },
    }
  )),
  (_descriptor15 = _applyDecoratedDescriptor(
    _class.prototype,
    "toggleList",
    [action],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return async (targetId) => {
          this.hasError = false;
          // Toggle the list in save to list modal
          this.myList = this.myList.map((list) => {
            if (list.id === targetId) {
              list.isSelected = !list.isSelected;
            }
            return list;
          });
        };
      },
    }
  )),
  (_descriptor16 = _applyDecoratedDescriptor(
    _class.prototype,
    "removeFromList",
    [action],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return async (selectedListId, selectedListTitle) => {
          const { gettext, interpolate } = this.i18n;
          this.isSubmitting.add(selectedListId);
          try {
            const response = await udApi.delete(
              `/users/me/subscribed-courses-collections/${selectedListId}/courses/${this.course.id}/`
            );
            if (response.status === 204) {
              document.dispatchEvent(
                new CustomEvent(ListEvents.REMOVE, {
                  detail: {
                    course: this.course,
                    listId: selectedListId,
                  },
                })
              );
              // course from course taking does not have a frontendTrackingId
              Tracker.publishEvent(
                new LearningListItemRemoveEvent({
                  listId: selectedListId,
                  courseId: this.course.id,
                  trackingId: this.course.frontendTrackingId
                    ? this.course.frontendTrackingId
                    : "",
                  uiRegion: `${this.uiRegion}`,
                })
              );
              this.handleToaster(gettext("Removed from list"));
            }
            runInAction(() => {
              this.isSubmitting.delete(selectedListId);
            });
          } catch (err) {
            var _response2;
            runInAction(() => (this.hasError = true));
            const errData =
              (_response2 = err.response) === null || _response2 === void 0
                ? void 0
                : _response2.data;
            const errMessage =
              ((errData === null || errData === void 0
                ? void 0
                : errData.results) &&
                errData.results[0]) ||
              (errData === null || errData === void 0
                ? void 0
                : errData.detail);
            this.handleToaster(
              interpolate(
                gettext("Failed to remove from %(listTitle)s"),
                {
                  listTitle: selectedListTitle,
                },
                true
              ),
              errMessage,
              "error"
            );
          } finally {
            runInAction(() => {
              this.isSubmitting.delete(selectedListId);
            });
          }
        };
      },
    }
  )),
  (_descriptor17 = _applyDecoratedDescriptor(
    _class.prototype,
    "saveToList",
    [action],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return async (selectedListId, selectedListTitle) => {
          const { gettext, interpolate } = this.i18n;
          this.isSubmitting.add(selectedListId);
          try {
            const response = await udApi.post(
              `/users/me/subscribed-courses-collections/${selectedListId}/courses/`,
              {
                course: this.course.id,
              }
            );
            if (response.status === 201) {
              document.dispatchEvent(
                new CustomEvent(ListEvents.ADD, {
                  detail: {
                    course: this.course,
                    listId: selectedListId,
                  },
                })
              );
              Tracker.publishEvent(
                new LearningListItemSaveEvent({
                  listId: selectedListId,
                  courseId: this.course.id,
                  trackingId: this.course.frontendTrackingId
                    ? this.course.frontendTrackingId
                    : "",
                  uiRegion: `${this.uiRegion}`,
                })
              );
              this.handleToaster(gettext("Saved to list"));
            }
            runInAction(() => {
              this.isSubmitting.delete(selectedListId);
            });
          } catch (err) {
            var _response3;
            runInAction(() => (this.hasError = true));
            const errData =
              (_response3 = err.response) === null || _response3 === void 0
                ? void 0
                : _response3.data;
            const errMessage =
              ((errData === null || errData === void 0
                ? void 0
                : errData.results) &&
                errData.results[0]) ||
              (errData === null || errData === void 0
                ? void 0
                : errData.detail);
            this.handleToaster(
              interpolate(
                gettext("Failed to save to %(listTitle)s"),
                {
                  listTitle: selectedListTitle,
                },
                true
              ),
              errMessage,
              "error"
            );
          } finally {
            runInAction(() => {
              this.isSubmitting.delete(selectedListId);
            });
          }
        };
      },
    }
  )),
  _applyDecoratedDescriptor(
    _class.prototype,
    "selectedList",
    [computed],
    Object.getOwnPropertyDescriptor(_class.prototype, "selectedList"),
    _class.prototype
  ),
  (_descriptor18 = _applyDecoratedDescriptor(
    _class.prototype,
    "fetchListData",
    [action],
    {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return async () => {
          const { gettext } = this.i18n;
          // Fetching the user's list and selected list with given course id
          this.isFetchingData = true;
          const loadLists = udApi.get(
            "/users/me/subscribed-courses-collections/"
          );
          const loadSelectedLists = udApi.get(
            `/users/me/subscribed-courses/${this.course.id}/collections/`
          );
          try {
            const [listResponse, selectedListResponse] = await Promise.all([
              loadLists,
              loadSelectedLists,
            ]);
            const selectedLists = selectedListResponse.data.results;
            const allLists = listResponse.data.results;
            runInAction(() => {
              allLists.forEach((listItem) => {
                listItem.isSelected = selectedLists.some(
                  (item) => item.id === listItem.id
                );
              });
              this.myList = allLists;
            });
          } catch (err) {
            var _response4;
            runInAction(() => (this.hasError = true));
            const errData =
              (_response4 = err.response) === null || _response4 === void 0
                ? void 0
                : _response4.data;
            const errMessage =
              ((errData === null || errData === void 0
                ? void 0
                : errData.results) &&
                errData.results[0]) ||
              (errData === null || errData === void 0
                ? void 0
                : errData.detail);
            this.handleToaster(
              gettext("Failed to load lists"),
              errMessage,
              "error"
            );
          } finally {
            runInAction(() => {
              this.isFetchingData = false;
            });
          }
        };
      },
    }
  ))),
  _class);
//# sourceMappingURL=save-to-list-button.mobx-store.js.map
